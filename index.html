<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ëš±ëšœë£¨ì˜ ë„ë©´ì†Œìƒìˆ </title>

  <!-- 2D/ì…ë©´ ìº¡ì²˜ìš© -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    :root{
      --bg:#f2f2f2;
      --panel:#ffffff;
      --ink:#222;
      --muted:#666;
      --line:#e7e7e7;
      --btn:#1f2937;
      --btn2:#2563eb;
      --danger:#dc2626;
      --ok:#16a34a;
      --radius:14px;
    }
    body{ margin:0; overflow:hidden; font-family:"Segoe UI","Malgun Gothic",system-ui,sans-serif; background:var(--bg); color:var(--ink); }
    button{ font:inherit; cursor:pointer; }
    a{ color:inherit; }

    /* âœ… ì™¼ìª½ íŒ¨ë„ */
    #ui{
      position:fixed; left:12px; top:12px; z-index:1000;
      width:360px; max-height:92vh; overflow:auto;
      background:rgba(255,255,255,.97);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:0 10px 30px rgba(0,0,0,.12);
      padding:12px;

      transition: transform 220ms ease;
      will-change: transform;
      --uiHide: 390px; /* JSë¡œ ì‹¤ì œ í­ ê³„ì‚°í•´ì„œ ë®ì–´ì”€ */
    }
    #ui.collapsed{ transform: translateX(calc(-1 * var(--uiHide))); }

    #ui::-webkit-scrollbar{ width:6px; }
    #ui::-webkit-scrollbar-thumb{ background:#cfcfcf; border-radius:10px; }

    /* âœ… íŒ¨ë„ í† ê¸€ ë²„íŠ¼ (í•­ìƒ ë³´ì´ê²Œ) */
    .uiToggle{
      position: fixed;
      left: 12px;
      top: 76px;
      z-index: 2001;
      width: 40px;
      height: 40px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.96);
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      font-weight: 900;
      cursor: pointer;
    }
    .uiToggle:hover{ background:#f6f6f6; }

    .topRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .title{ font-weight:800; font-size:16px; display:flex; align-items:center; gap:8px; }
    .ver{ font-size:11px; padding:2px 6px; border-radius:6px; background:#111827; color:#fff; }

    .topBtns{ display:flex; gap:6px; }
    .miniBtn{
      border:1px solid var(--line); background:#fff; color:var(--ink);
      padding:7px 9px; border-radius:10px; font-size:12px;
    }
    .miniBtn:hover{ background:#f6f6f6; }
    .miniBtn.danger{ border-color:#ffd1d1; color:var(--danger); }
    .miniBtn.primary{ border-color:#c7ddff; color:#1d4ed8; }

    .modeRow{ margin-top:10px; display:flex; gap:8px; }
    .modeBtn{
      flex:1; border:none; border-radius:12px; padding:10px 0;
      background:#e9e9e9; color:#666; font-weight:900;
    }
    .modeBtn.active{ background:var(--btn); color:#fff; }

    .block{ margin-top:10px; border:1px solid var(--line); border-radius:12px; padding:10px; background:#fff; }
    .hint{ font-size:12px; color:var(--muted); line-height:1.5; }

    input[type=number]{
      width:100%;
      box-sizing:border-box;
      padding:10px;
      border:1px solid #d8d8d8;
      border-radius:12px;
      font-size:12px;
      outline:none;
    }
    input[type=number]:focus{ border-color:#a7c7ff; box-shadow:0 0 0 3px rgba(37,99,235,.12); }

    textarea{
      width:100%; height:170px; box-sizing:border-box;
      margin-top:8px;
      border:1px solid #d8d8d8; border-radius:12px;
      padding:10px; font-size:12px; resize:vertical;
      user-select:text;
    }
    .rowBtns{ display:flex; gap:8px; margin-top:8px; }
    .rowBtns button{ flex:1; }

    #buildBtn{
      width:100%; margin-top:10px;
      border:none; border-radius:12px;
      padding:12px 0; font-weight:900; font-size:14px;
      background:var(--btn2); color:#fff;
    }
    #buildBtn:hover{ filter:brightness(0.95); }

    #status{
      margin-top:10px; font-size:12px; line-height:1.45;
      color:var(--muted);
      background:#f8fafc; border:1px solid #eef2ff;
      padding:10px; border-radius:12px;
    }
    #status b{ color:var(--ink); }
    .ok{ color:var(--ok); font-weight:900; }
    .bad{ color:var(--danger); font-weight:900; }

    details{ margin-top:10px; }
    summary{
      cursor:pointer; font-weight:900; font-size:13px;
      list-style:none;
    }
    summary::-webkit-details-marker{ display:none; }
    .detailsBody{
      margin-top:8px; font-size:12px; color:var(--muted); line-height:1.6;
      border:1px dashed #e5e7eb; border-radius:12px; padding:10px; background:#fafafa;
    }
    kbd{ background:#fff; border:1px solid #ddd; padding:1px 6px; border-radius:6px; font-family:monospace; font-weight:900; }

    /* âœ… ì²´í¬ë°•ìŠ¤(ìƒˆë¡œê³ ì¹¨ ìë™ ì´ˆê¸°í™”) */
    .chkRow{ display:flex; gap:8px; align-items:center; margin-top:10px; }
    .chkRow input{ width:16px; height:16px; }
    .chkRow label{ font-size:12px; color:#444; font-weight:800; user-select:none; }

    /* Viewer */
    #viewer{ position:fixed; inset:0; z-index:1; }

    #twod{ position:absolute; inset:0; overflow:auto; display:none; background:#fff;
      background-image: linear-gradient(#eee 1px, transparent 1px), linear-gradient(90deg, #eee 1px, transparent 1px);
      background-size:40px 40px;
    }
    #three{ position:absolute; inset:0; display:block; }
    #elev{ position:absolute; inset:0; overflow:auto; display:none; background:#fff;
      background-image: linear-gradient(#f0f0f0 1px, transparent 1px), linear-gradient(90deg, #f0f0f0 1px, transparent 1px);
      background-size:40px 40px;
      padding:18px 18px 80px 18px;
      box-sizing:border-box;
    }

    .room2d{
      position:absolute; border:2px solid #666; box-shadow:2px 2px 6px rgba(0,0,0,.12);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-size:12px; padding:6px; cursor:grab; user-select:none; touch-action:none;
    }
    .room2d.dragging{ cursor:grabbing; opacity:.85; z-index:999; box-shadow:6px 6px 16px rgba(0,0,0,.18); }

    /* ì…ë©´ ì¹´ë“œ */
    .elevHeader{
      position:sticky; top:0; z-index:5;
      background:rgba(255,255,255,.92);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow:0 6px 18px rgba(0,0,0,.08);
      backdrop-filter: blur(6px);
      margin-bottom:14px;
    }
    .elevGrid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(330px, 1fr));
      gap:14px;
    }
    .elevCard{
      background:#fff;
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 22px rgba(0,0,0,.07);
    }
    .elevTitle{ font-weight:900; font-size:14px; margin-bottom:8px; }
    .elevMeta{ font-size:12px; color:var(--muted); margin-bottom:10px; line-height:1.4; }
    .wallRow{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .wallBox{
      border:1px solid #e5e7eb;
      border-radius:12px;
      padding:10px;
      background:#fafafa;
    }
    .wallLabel{ font-weight:900; font-size:12px; margin-bottom:6px; color:#111; }
    .wallSvgWrap{ width:100%; overflow:hidden; }
    .warn{ margin-top:8px; font-size:12px; color:var(--danger); font-weight:900; }
    .good{ margin-top:8px; font-size:12px; color:var(--ok); font-weight:900; }
    .note{ margin-top:8px; font-size:12px; color:#374151; font-weight:900; }

    /* Tooltip (3D) */
    #tooltip{
      position:fixed; display:none; z-index:9999; pointer-events:none;
      background:rgba(17,24,39,.95); color:#fff;
      padding:10px 12px; border-radius:12px;
      font-size:12px; line-height:1.55;
      box-shadow:0 18px 50px rgba(0,0,0,.35);
      min-width:240px;
      border:1px solid rgba(255,255,255,.12);
    }
    #tooltip b{ display:block; font-size:13px; margin-bottom:6px; color:#fde68a; }
    .ttRow{ display:flex; justify-content:space-between; gap:12px; }
    .ttLbl{ color:#cbd5e1; }
    .ttVal{ font-weight:900; }

    /* âœ… ì¤Œ HUD (2D/ì…ë©´) */
    #zoomHud{
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 1600;
      display: none;
      gap: 6px;
      align-items: center;
      background: rgba(255,255,255,.94);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 8px 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      user-select:none;
    }
    #zoomHud button{
      width: 34px; height: 34px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: #fff;
      font-weight: 900;
      cursor: pointer;
    }
    #zoomHud button:hover{ background:#f6f6f6; }
    #zoomLabel{
      font-size: 12px;
      font-weight: 900;
      min-width: 64px;
      text-align: center;
      color:#111;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="tooltip"></div>

  <!-- âœ… ì¤Œ HUD -->
  <div id="zoomHud" aria-label="Zoom controls">
    <button id="zoomOut" title="ì¶•ì†Œ">âˆ’</button>
    <span id="zoomLabel">100%</span>
    <button id="zoomIn" title="í™•ëŒ€">ï¼‹</button>
    <button id="zoomReset" title="100%">âŸ²</button>
  </div>

  <!-- âœ… ë©”ë‰´ ì ‘ê¸°/í¼ì¹˜ê¸° ë²„íŠ¼ -->
  <button id="uiToggle" class="uiToggle" title="ë©”ë‰´ ì ‘ê¸°">â—€</button>

  <div id="ui">
    <div class="topRow">
      <div class="title">ëš±ëšœë£¨ì˜ ë„ë©´ì†Œìƒìˆ  <span class="ver">v2.40</span></div>
      <div class="topBtns">
        <button id="resetBtn" class="miniBtn danger">ì´ˆê¸°í™”</button>
        <button id="jsonLoadBtn" class="miniBtn">JSON ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button id="jsonSaveBtn" class="miniBtn primary">JSON ì €ì¥</button>
        <input id="jsonFile" type="file" accept="application/json" style="display:none" />
      </div>
    </div>

    <div class="modeRow">
      <button id="mode2d" class="modeBtn">ğŸ“Š 2D</button>
      <button id="mode3d" class="modeBtn active">ğŸ§Š 3D</button>
      <button id="modeElev" class="modeBtn">ğŸ§± ì…ë©´</button>
    </div>

    <div class="block">
      <div class="hint">
        <b>ë”± 2ë‹¨ê³„ë§Œ í•˜ì„¸ìš”.</b><br/>
        1) ì•„ë˜ ì¹¸ì— â€œë°© ëª©ë¡â€ ë¶™ì—¬ë„£ê¸°<br/>
        2) <b>[ë„ë©´ ìƒì„±]</b> ëˆ„ë¥´ê¸°
      </div>

      <!-- âœ… ìƒˆë¡œê³ ì¹¨ ìë™ ì´ˆê¸°í™” ì˜µì…˜ -->
      <div class="chkRow">
        <input id="autoClear" type="checkbox" checked />
        <label for="autoClear">ìƒˆë¡œê³ ì¹¨(F5)í•˜ë©´ ì…ë ¥/ë„í˜• ìë™ ì´ˆê¸°í™”</label>
      </div>

      <!-- ë²½ë‘ê»˜ ì…ë ¥ (ê¸°ë³¸ 200mm) -->
      <div style="margin-top:10px;">
        <div style="font-size:12px;font-weight:900;color:#111;">ë²½ë‘ê»˜(mm) <span style="font-weight:700;color:#666;">(ê¸°ë³¸ 200, ë¹„ì›Œë„ ìë™ 200)</span></div>
        <input id="wallThk" type="number" value="200" min="50" max="500" step="10" />
        <div class="hint" style="margin-top:6px;">
          Â· 200ì²˜ëŸ¼ í° ê°’ì€ <b>mm</b>ë¡œ ë³´ê³  0.2më¡œ ë³€í™˜í•©ë‹ˆë‹¤.<br/>
          Â· 0.2ì²˜ëŸ¼ ì‘ì€ ê°’ì€ <b>m</b>ë¡œ ë´…ë‹ˆë‹¤.
        </div>
      </div>

      <textarea id="dataInput" placeholder="âœ… ì œì¼ ì‰¬ìš´ ì…ë ¥(í—¤ë” ì—†ì–´ë„ ë¨)
ê±°ì‹¤ 5.0 4.0
ë°©1 2.4 2.4

âœ… ì—‘ì…€/êµ¬ê¸€ì‹œíŠ¸ í‘œ í†µì§¸ë¡œ ë³µì‚¬ë„ OK
ê³µê°„ID	ê³µê°„ëª…	ê°€ë¡œ(m)	ì„¸ë¡œ(m)	ë²½ë†’ì´(m)	ì°½ë©´ì (ã¡)

âœ… (ì„ íƒ) ì°½ì„ 'ì§„ì§œ ìœ„ì¹˜'ì— ë‘ê³  ì‹¶ìœ¼ë©´ ì•„ë˜ ì¤‘ í•˜ë‚˜ë¥¼ ì¶”ê°€
ë°©ë²•A: ì°½ë©´(ì•/ë’¤/ì¢Œ/ìš°) 1ê°œë§Œ ì§€ì •(ì´ ì°½ë©´ì ì„ ê·¸ ë©´ì—ë§Œ í‘œì‹œ)
ê³µê°„ID	ê³µê°„ëª…	ê°€ë¡œ(m)	ì„¸ë¡œ(m)	ë²½ë†’ì´(m)	ì°½ë©´ì (ã¡)	ì°½ë©´

ë°©ë²•B: ë©´ë³„ ì°½ë©´ì (ì°½ì•/ì°½ë’¤/ì°½ì¢Œ/ì°½ìš°)
ê³µê°„ID	ê³µê°„ëª…	ê°€ë¡œ(m)	ì„¸ë¡œ(m)	ë²½ë†’ì´(m)	ì°½ì•	ì°½ë’¤	ì°½ì¢Œ	ì°½ìš°"></textarea>

      <div class="rowBtns">
        <button id="pasteBtn" class="miniBtn">ğŸ“‹ í´ë¦½ë³´ë“œ ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button id="sampleBtn" class="miniBtn">ğŸ§ª ìƒ˜í”Œ ë„£ê¸°</button>
        <button id="clearInputBtn" class="miniBtn">ğŸ§½ ì…ë ¥ ì§€ìš°ê¸°</button>
      </div>

      <button id="buildBtn">ğŸ—ï¸ ë„ë©´ ìƒì„±</button>

      <div id="status">
        <b>ìƒíƒœ</b><br/>
        ì•„ì§ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìœ„ ì¹¸ì— ë¶™ì—¬ë„£ê³  [ë„ë©´ ìƒì„±]ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
      </div>

      <details>
        <summary>ì‚¬ìš©ë²• (30ì´ˆ)</summary>
        <div class="detailsBody">
          1) ì—‘ì…€/êµ¬ê¸€ì‹œíŠ¸ì—ì„œ <b>ë°© ëª©ë¡ í‘œ</b>ë¥¼ ë“œë˜ê·¸í•´ì„œ ë³µì‚¬<br/>
          2) ì´ í˜ì´ì§€ì— ë¶™ì—¬ë„£ê¸°<br/>
          3) <b>[ë„ë©´ ìƒì„±]</b><br/><br/>
          - 2D: ë°© ì¡°ê° ë“œë˜ê·¸ë¡œ ë°°ì¹˜ (íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ, <kbd>Shift</kbd>+íœ ì€ ìŠ¤í¬ë¡¤)<br/>
          - 3D: <kbd>Shift</kbd> ëˆ„ë¥´ê³  ë“œë˜ê·¸í•˜ë©´ ë°© ì´ë™, ëª¨ë°”ì¼ì€ í•€ì¹˜ ì¤Œ OK<br/>
          - ì…ë©´: ì „ê°œë„(4ë©´) ìë™ ìƒì„±, <kbd>Ctrl</kbd>+íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ<br/><br/>
          íŒ: ì…ë©´ì€ í™”ë©´ì´ ë„“ì–´ì•¼ í¸í•´ì„œ <b>ìë™ìœ¼ë¡œ ì™¼ìª½ ë©”ë‰´ê°€ ì ‘í™ë‹ˆë‹¤.</b><br/>
          ë‹¤ì‹œ í¼ì¹˜ë ¤ë©´ ì™¼ìª½ ìœ„ <b>â—€/â–¶</b> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.
        </div>
      </details>

      <details>
        <summary>ë©´ì /ë³´ì • ì„¤ëª… (ì¤‘ìš”)</summary>
        <div class="detailsBody">
          âœ… <b>ìˆœë©´ì (ì—‘ì…€ ë™ì¼)</b> = ê°€ë¡œÃ—ì„¸ë¡œ<br/>
          âš ï¸ <b>ë²½ í¬í•¨ ì¶”ì •ë©´ì (ì°¸ê³ )</b> = (ê°€ë¡œ+2t)Ã—(ì„¸ë¡œ+2t)<br/><br/>
          ë‹¨, ë°©ë¼ë¦¬ ë¶™ì–´ ìˆìœ¼ë©´ ê³µìœ ë²½ì´ ìƒê¸°ë¯€ë¡œ<br/>
          â€œë²½ í¬í•¨ ì¶”ì •ë©´ì â€ì€ <b>ë°©ë³„ ìµœëŒ€ì¹˜</b> ëŠë‚Œìœ¼ë¡œ ë³´ì„¸ìš”(ì¤‘ë³µ ê°€ëŠ¥).<br/><br/>
          ì´ ì‚¬ì´íŠ¸ëŠ” <b>ì—‘ì…€ê³¼ ê°™ì€ ìˆœë©´ì </b>ì„ ê¸°ë³¸ìœ¼ë¡œ ìœ ì§€í•˜ê³ ,<br/>
          ë²½ë‘ê»˜ëŠ” <b>3D ë²½ ë‘ê»˜/ë²½ì²´ë¶€í”¼ ì¶”ì •</b>ì— íŠ¹íˆ ìœ ìš©í•˜ê²Œ ì“°ì…ë‹ˆë‹¤.
        </div>
      </details>

      <details>
        <summary>ë°ì´í„° í˜•ì‹ (ì¤‘ìš”)</summary>
        <div class="detailsBody">
          ìµœì†Œ 3ê°œë§Œ ìˆì–´ë„ ë©ë‹ˆë‹¤: <b>ë°©ì´ë¦„ / ê°€ë¡œ / ì„¸ë¡œ</b><br/>
          (ID/ë†’ì´/ì°½ì€ ì—†ì–´ë„ ìë™ ì²˜ë¦¬)<br/><br/>

          âœ… ì°½(ì´ˆë³´ëª¨ë“œ) ì…ë ¥<br/>
          - <b>ì°½ë©´ì (ã¡)</b>ë§Œ ë„£ì–´ë„ ë©ë‹ˆë‹¤. ë‹¤ë§Œ <b>ìœ„ì¹˜ë¥¼ ëª¨ë¥´ë©´</b> ë„ë©´ì— ê±°ì§“ìœ¼ë¡œ ë°°ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤(=í‘œì‹œ ì•ˆ í•¨).<br/><br/>

          âœ… ì°½ì„ â€œì§„ì§œ ìœ„ì¹˜â€ì— í‘œì‹œí•˜ê³  ì‹¶ìœ¼ë©´ (ì„ íƒ)<br/>
          ë°©ë²•A) <b>ì°½ë©´</b> ì—´ ì¶”ê°€: <b>ì•/ë’¤/ì¢Œ/ìš°</b> ì¤‘ í•˜ë‚˜ ì…ë ¥ â†’ ì´ ì°½ë©´ì ì„ ê·¸ ë©´ì—ë§Œ í‘œì‹œ<br/>
          ë°©ë²•B) <b>ì°½ì•/ì°½ë’¤/ì°½ì¢Œ/ì°½ìš°</b> ì—´ ì¶”ê°€ â†’ ë©´ë³„ë¡œ ì •í™•íˆ í‘œì‹œ<br/><br/>

          ì˜ˆ) ì°½ë©´ ë°©ì‹<br/>
          ê±°ì‹¤	5.0	4.0	2.3	3.2	ì•<br/>
          ì˜ˆ) ë©´ë³„ ë°©ì‹<br/>
          ê±°ì‹¤	5.0	4.0	2.3	1.2	0	0.8	1.2
        </div>
      </details>

      <details>
        <summary>ë‹¨ì¶•í‚¤</summary>
        <div class="detailsBody">
          <b>ê³µí†µ</b>: <kbd>P</kbd> ìº¡ì²˜ ì €ì¥ ğŸ“¸<br/>
          <b>3D</b>: <kbd>Shift</kbd>+ë“œë˜ê·¸ ë°© ì´ë™ / <kbd>L</kbd> ë¼ë²¨ í† ê¸€ / <kbd>G</kbd> ì •ë‹µìœ ë ¹ í† ê¸€
        </div>
      </details>

      <details>
        <summary>ë‹¤ìš´ë¡œë“œ/ìƒë‹´</summary>
        <div class="detailsBody">
          ğŸ“‚ ì—‘ì…€í‚¤íŠ¸: <a href="https://drive.google.com/file/d/112Y3BEiE_1ooNrF5tPZd6SnDRHyXcrDg/view?usp=sharing" target="_blank">ë‹¤ìš´</a><br/>
          ğŸ“‘ êµ¬ê¸€ì‹œíŠ¸ ì‚¬ë³¸: <a href="https://docs.google.com/spreadsheets/d/1GW5nJHgax0XTXOPyyVusVr_WKob3S5URJG1lSiAM6bE/copy" target="_blank">ì‚¬ë³¸ ë§Œë“¤ê¸°</a><br/>
          ğŸ’¬ í†¡í†¡: <a href="https://talk.naver.com/W4HB1I" target="_blank">ìƒë‹´í•˜ê¸°</a><br/>
          ğŸŒ¿ ê·¸ë¦°ë¦¬ëª¨ë¸ë§: <a href="https://yugy.store" target="_blank">yugy.store</a>
        </div>
      </details>
    </div>
  </div>

  <div id="viewer">
    <div id="twod"></div>
    <div id="three"></div>
    <div id="elev"></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // -----------------------------
    // 0) ìƒíƒœ/íŒ”ë ˆíŠ¸
    // -----------------------------
    const EXCEL_COLORS = [
      "#FFCCCC","#FFE5CC","#FFFFCC","#E5FFCC","#CCFFCC","#CCFFE5","#CCFFFF","#CCE5FF","#CCCCFF","#E5CCFF",
      "#FFCCFF","#FFCCE5","#FFB2B2","#FFD6A5","#FFEF9F","#CAE799","#A6E3A1","#99DDCC","#9FDBFF","#ADC1FF",
      "#C8B2FF","#E0B2FF","#FFB2F5","#FFB2D7","#FFB2B2","#FF8282","#FFAA64","#FFD246","#B4DC5A","#78D296"
    ];

    let mode = '3d';
    /**
     * globalData row:
     * {id,name,w,d,h, winTotal, winPlaced, win:{front,back,left,right}, x2d,y2d}
     */
    let globalData = [];
    let globalWallThicknessMm = 200;
    let globalWallThicknessM = 0.2;

    const $ = (id) => document.getElementById(id);
    const statusEl = $('status');
    const inputEl = $('dataInput');
    const tooltip = $('tooltip');
    const ui = $('ui');
    const uiToggle = $('uiToggle');
    const autoClearEl = $('autoClear');

    // Zoom HUD
    const zoomHud = $('zoomHud');
    const zoomLabel = $('zoomLabel');
    const zoomInBtn = $('zoomIn');
    const zoomOutBtn = $('zoomOut');
    const zoomResetBtn = $('zoomReset');

    function setStatus(html){ statusEl.innerHTML = html; }

    // -----------------------------
    // âœ… UI ì ‘ê¸°/í¼ì¹˜ê¸°
    // -----------------------------
    let uiCollapsed = localStorage.getItem('uiCollapsed') === '1';

    function calcUiHide(){
      const w = ui.getBoundingClientRect().width || 360;
      ui.style.setProperty('--uiHide', (w + 16) + 'px');
    }

    function applyUiCollapsed(){
      ui.classList.toggle('collapsed', uiCollapsed);
      uiToggle.textContent = uiCollapsed ? 'â–¶' : 'â—€';
      uiToggle.title = uiCollapsed ? 'ë©”ë‰´ í¼ì¹˜ê¸°' : 'ë©”ë‰´ ì ‘ê¸°';
    }

    function setUiCollapsed(next){
      uiCollapsed = !!next;
      localStorage.setItem('uiCollapsed', uiCollapsed ? '1' : '0');
      calcUiHide();
      applyUiCollapsed();
    }

    uiToggle.addEventListener('click', ()=> setUiCollapsed(!uiCollapsed));

    // -----------------------------
    // âœ… ìƒˆë¡œê³ ì¹¨ ìë™ ì´ˆê¸°í™”(ì˜µì…˜)
    // -----------------------------
    const savedAutoClear = localStorage.getItem('autoClearOnReload');
    autoClearEl.checked = (savedAutoClear === null) ? true : (savedAutoClear === '1');
    autoClearEl.addEventListener('change', ()=>{
      localStorage.setItem('autoClearOnReload', autoClearEl.checked ? '1' : '0');
    });

    // -----------------------------
    // âœ… 2D/ì…ë©´ ì¤Œ
    // -----------------------------
    let twodZoom = parseFloat(localStorage.getItem('twodZoom') || '1') || 1;
    let elevZoom = parseFloat(localStorage.getItem('elevZoom') || '1') || 1;

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function clampZoom(z){ return clamp(z, 0.35, 3.2); }

    function setZoomForMode(z){
      if (mode === '2d'){
        twodZoom = clampZoom(z);
        $('twod').style.zoom = String(twodZoom);
        localStorage.setItem('twodZoom', String(twodZoom));
        zoomLabel.textContent = `${Math.round(twodZoom*100)}%`;
      } else if (mode === 'elev'){
        elevZoom = clampZoom(z);
        $('elev').style.zoom = String(elevZoom);
        localStorage.setItem('elevZoom', String(elevZoom));
        zoomLabel.textContent = `${Math.round(elevZoom*100)}%`;
      }
    }

    function syncZoomHud(){
      const on = (mode==='2d' || mode==='elev');
      zoomHud.style.display = on ? 'flex' : 'none';
      if (!on) return;
      if (mode==='2d') zoomLabel.textContent = `${Math.round(twodZoom*100)}%`;
      if (mode==='elev') zoomLabel.textContent = `${Math.round(elevZoom*100)}%`;
    }

    zoomInBtn.addEventListener('click', ()=> setZoomForMode((mode==='2d'?twodZoom:elevZoom) * 1.12));
    zoomOutBtn.addEventListener('click', ()=> setZoomForMode((mode==='2d'?twodZoom:elevZoom) * 0.90));
    zoomResetBtn.addEventListener('click', ()=> setZoomForMode(1));

    // Wheel zoom rules:
    // - 2D: íœ =ì¤Œ, Shift+íœ =ìŠ¤í¬ë¡¤(ê¸°ë³¸ ë™ì‘)
    // - ì…ë©´: Ctrl(or Cmd)+íœ =ì¤Œ, ê·¸ëƒ¥ íœ ì€ ìŠ¤í¬ë¡¤
    function attachWheelZoom(el, modeName){
      el.addEventListener('wheel', (e)=>{
        if (modeName === '2d'){
          if (e.shiftKey) return; // Shift+íœ ì€ ìŠ¤í¬ë¡¤ ìœ ì§€
          e.preventDefault();
          const dir = e.deltaY < 0 ? 1.10 : 0.92;
          setZoomForMode(twodZoom * dir);
          return;
        }
        if (modeName === 'elev'){
          if (!(e.ctrlKey || e.metaKey)) return;
          e.preventDefault();
          const dir = e.deltaY < 0 ? 1.10 : 0.92;
          setZoomForMode(elevZoom * dir);
        }
      }, { passive:false });
    }

    // Pinch zoom (mobile) for 2D/elev
    function attachPinchZoom(el, getZ, setZ){
      let pinchStartDist = 0;
      let pinchStartZoom = 1;

      function dist(t1,t2){
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.hypot(dx,dy);
      }

      el.addEventListener('touchstart', (e)=>{
        if (e.touches && e.touches.length === 2){
          pinchStartDist = dist(e.touches[0], e.touches[1]);
          pinchStartZoom = getZ();
        }
      }, { passive:false });

      el.addEventListener('touchmove', (e)=>{
        if (e.touches && e.touches.length === 2){
          e.preventDefault();
          const d = dist(e.touches[0], e.touches[1]);
          if (!pinchStartDist) return;
          const ratio = d / pinchStartDist;
          setZ(pinchStartZoom * ratio);
        }
      }, { passive:false });
    }

    // -----------------------------
    // 1) ë‹¨ìœ„/íŒŒì„œ
    // -----------------------------
    function numOnly(v){
      if (v === null || v === undefined) return '';
      return String(v).replace(/[^0-9.\-]/g,'').trim();
    }
    function smartUnit(v){
      const s = numOnly(v);
      const n = parseFloat(s);
      if (!isFinite(n) || n <= 0) return 0;
      if (n > 100) return n / 1000; // mm ì¶”ì •
      return n;
    }
    function smartThickness(v, fallbackM){
      const s = numOnly(v);
      const n = parseFloat(s);
      if (!isFinite(n) || n <= 0) return fallbackM;
      if (n > 10) return n / 1000; // 200 -> 0.2m
      return n; // 0.2 -> 0.2m
    }
    function getGlobalThickness(){
      const raw = $('wallThk').value;
      let t = smartThickness(raw, 0.2);
      if (!isFinite(t) || t <= 0) t = 0.2;
      if (t < 0.03) t = 0.03;
      if (t > 1.0) t = 1.0;
      globalWallThicknessM = t;
      globalWallThicknessMm = Math.round(t*1000);
      return t;
    }

    function parseAreaCell(v){
      const n = parseFloat(numOnly(v));
      return (isFinite(n) && n > 0) ? n : 0;
    }
    function normFace(v){
      const s = String(v ?? '').trim().toLowerCase();
      if (!s) return null;
      if (/^(f|front)$/.test(s) || /ì•|ì „ë©´/.test(s)) return 'front';
      if (/^(b|back)$/.test(s)  || /ë’¤|í›„ë©´/.test(s)) return 'back';
      if (/^(l|left)$/.test(s)  || /ì¢Œ|ì™¼/.test(s)) return 'left';
      if (/^(r|right)$/.test(s) || /ìš°|ì˜¤ë¥¸/.test(s)) return 'right';
      return null;
    }

    function splitCols(line){
      const t = (line || '').trim();
      if (!t) return null;
      if (t.includes('\t')) return t.split('\t').map(x=>x.trim());
      if (t.includes(',')) return t.split(',').map(x=>x.trim());
      return t.split(/\s+/).map(x=>x.trim());
    }

    function detectHeader(cols){
      const lower = cols.map(c => String(c).toLowerCase().replace(/\s/g,'').replace(/[()]/g,''));
      const map = {};
      lower.forEach((c,i)=>{
        if (/ê³µê°„id|ë°©id|id|ë²ˆí˜¸/.test(c)) map.id=i;
        if (/ê³µê°„ëª…|ë°©ì´ë¦„|ì´ë¦„|name/.test(c)) map.name=i;
        if (/ê°€ë¡œ|width|w|ê¸¸ì´/.test(c)) map.w=i;
        if (/ì„¸ë¡œ|depth|d|ë„ˆë¹„/.test(c)) map.d=i;
        if (/ë²½ë†’ì´|ë†’ì´|height|h/.test(c)) map.h=i;

        // total window area
        if (/ì°½ë©´ì |ì°½ë¬¸ë©´ì |windowarea|winarea/.test(c)) map.winTotal=i;

        // face selector (single face for total)
        if (/ì°½ë©´|ì°½ìœ„ì¹˜|ì°½ë°©í–¥|winface|windowface|face/.test(c)) map.winFace=i;

        // per-face window areas
        if (/ì°½ì•|ì°½ë©´ì ì•|ì „ë©´ì°½|winfront|windowfront/.test(c)) map.winFront=i;
        if (/ì°½ë’¤|ì°½ë©´ì ë’¤|í›„ë©´ì°½|winback|windowback/.test(c)) map.winBack=i;
        if (/ì°½ì¢Œ|ì°½ë©´ì ì¢Œ|ì¢Œì¸¡ì°½|winleft|windowleft/.test(c)) map.winLeft=i;
        if (/ì°½ìš°|ì°½ë©´ì ìš°|ìš°ì¸¡ì°½|winright|windowright/.test(c)) map.winRight=i;
      });
      if (map.name !== undefined && map.w !== undefined && map.d !== undefined) return map;
      return null;
    }

    // âœ… ì´ˆë³´ìš©: í—¤ë” ì—†ì–´ë„ "ë°©ì´ë¦„ ê°€ë¡œ ì„¸ë¡œ" 3ì—´ì´ë©´ ì¸ì‹
    function parseLooseRow(cols){
      // 1) "ID ì´ë¦„ ê°€ë¡œ ì„¸ë¡œ ..." í˜•íƒœ
      const idTry = parseInt(numOnly(cols[0] ?? ''), 10);
      const nameTry = String(cols[1] ?? '').trim();

      const wTry1 = smartUnit(cols[2]);
      const dTry1 = smartUnit(cols[3]);
      if (isFinite(idTry) && idTry > 0 && nameTry && wTry1 > 0 && dTry1 > 0){
        let h = smartUnit(cols[4]); if (!h) h = 2.3;
        let winTotal = parseAreaCell(cols[5]);
        return { id:idTry, name:nameTry, w:wTry1, d:dTry1, h, winTotal, winPlaced:false, win:{front:0,back:0,left:0,right:0} };
      }

      // 2) "ì´ë¦„ ê°€ë¡œ ì„¸ë¡œ ..." í˜•íƒœ (ID ìë™)
      const name2 = String(cols[0] ?? '').trim();
      const wTry2 = smartUnit(cols[1]);
      const dTry2 = smartUnit(cols[2]);
      if (name2 && wTry2 > 0 && dTry2 > 0){
        let h = smartUnit(cols[3]); if (!h) h = 2.3;
        let winTotal = parseAreaCell(cols[4]);
        return { id:0, name:name2, w:wTry2, d:dTry2, h, winTotal, winPlaced:false, win:{front:0,back:0,left:0,right:0} };
      }

      return null;
    }

    function parseText(text){
      const lines = String(text||'').split(/\r?\n/);
      const parsed = [];
      let headerMap = null;
      let autoId = 1;
      let skipped = 0;

      for (const line of lines){
        const cols = splitCols(line);
        if (!cols) continue;

        if (!headerMap){
          const hm = detectHeader(cols);
          if (hm){
            headerMap = hm;
            continue;
          }
        }

        // í—¤ë” ì—†ìœ¼ë©´ ëŠìŠ¨ íŒŒì‹±
        if (!headerMap){
          const loose = parseLooseRow(cols);
          if (loose){
            if (!loose.id) loose.id = autoId;
            parsed.push(loose);
            autoId = Math.max(autoId, loose.id + 1);
          } else {
            skipped++;
          }
          continue;
        }

        const idxId = headerMap?.id ?? 0;
        const idxName = headerMap?.name ?? 1;
        const idxW = headerMap?.w ?? 2;
        const idxD = headerMap?.d ?? 3;
        const idxH = headerMap?.h ?? 4;

        const name = String(cols[idxName] ?? '').trim();
        if (!name){ skipped++; continue; }

        let id = parseInt(numOnly(cols[idxId] ?? ''),10);
        if (!isFinite(id) || id <= 0) id = autoId;

        const w = smartUnit(cols[idxW]);
        const d = smartUnit(cols[idxD]);
        let h = smartUnit(cols[idxH]);
        if (!h) h = 2.3;

        // Windows: total + (optional) face or per-face
        const idxWinTotal = headerMap?.winTotal;
        const idxWinFace  = headerMap?.winFace;
        const idxWinFront = headerMap?.winFront;
        const idxWinBack  = headerMap?.winBack;
        const idxWinLeft  = headerMap?.winLeft;
        const idxWinRight = headerMap?.winRight;

        const win = { front:0, back:0, left:0, right:0 };
        let winTotal = 0;
        let winPlaced = false;

        // per-face first
        const wf = (idxWinFront !== undefined) ? parseAreaCell(cols[idxWinFront]) : 0;
        const wb = (idxWinBack  !== undefined) ? parseAreaCell(cols[idxWinBack])  : 0;
        const wl = (idxWinLeft  !== undefined) ? parseAreaCell(cols[idxWinLeft])  : 0;
        const wr = (idxWinRight !== undefined) ? parseAreaCell(cols[idxWinRight]) : 0;

        if (wf+wb+wl+wr > 0){
          win.front = wf; win.back = wb; win.left = wl; win.right = wr;
          winTotal = wf+wb+wl+wr;
          winPlaced = true;
        } else {
          // legacy total
          if (idxWinTotal !== undefined){
            winTotal = parseAreaCell(cols[idxWinTotal]);
          } else {
            // try inline text hint: "ì°½ë©´ì =3.2" ê°™ì€ ê²ƒ
            const joined = cols.join(' ');
            const m = joined.match(/ì°½ë©´ì \s*=?\s*([0-9.]+)/);
            if (m){
              const wa = parseFloat(m[1]);
              if (isFinite(wa) && wa > 0) winTotal = wa;
            }
          }

          // optional face selector
          if (winTotal > 0 && idxWinFace !== undefined){
            const face = normFace(cols[idxWinFace]);
            if (face){
              win[face] = winTotal;
              winPlaced = true;
            }
          }
        }

        if (w > 0 && d > 0){
          parsed.push({ id, name, w, d, h, winTotal, winPlaced, win });
          autoId = Math.max(autoId, id + 1);
        } else {
          skipped++;
        }
      }
      return { parsed, skipped };
    }

    // -----------------------------
    // 2) ì´ˆê¸°í™”
    // -----------------------------
    const twod = $('twod');
    const elev = $('elev');
    const threeEl = $('three');

    function setDefaultStatus(){
      setStatus(`<b>ìƒíƒœ</b><br/>ì•„ì§ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìœ„ ì¹¸ì— ë¶™ì—¬ë„£ê³  <b>[ë„ë©´ ìƒì„±]</b>ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.`);
    }

    function hardReset({ clearInput=true } = {}){
      twod.innerHTML = '';
      elev.innerHTML = '';

      pieces.forEach(p => scene.remove(p));
      ghosts.forEach(g => scene.remove(g));
      pieces = []; ghosts = []; hitMeshes = []; labels3D = [];
      dragging = false;
      draggedGroup = null;

      globalData = [];
      if (clearInput) inputEl.value = '';

      tooltip.style.display = 'none';
      setStatus(`<b>ìƒíƒœ</b><br/>ì´ˆê¸°í™” ì™„ë£Œ. ë‹¤ì‹œ ë¶™ì—¬ë„£ê³  <b>[ë„ë©´ ìƒì„±]</b> ëˆ„ë¥´ì„¸ìš”.`);
    }

    function maybeAutoClearOnReload(){
      if (!autoClearEl.checked) return;
      const clear = ()=>{
        inputEl.value = '';
        hardReset({ clearInput:true });
        setDefaultStatus();
      };
      clear();
      setTimeout(clear, 0);
      setTimeout(clear, 80);
    }

    window.addEventListener('pageshow', ()=>{
      maybeAutoClearOnReload();
    });

    // -----------------------------
    // 3) 2D
    // -----------------------------
    const SCALE_2D = 40;
    let active2D = null;
    let active2DOffset = { x:0, y:0 };

    function build2D(){
      twod.innerHTML = '';
      if (!globalData.length) return;

      const START_X = 380, START_Y = 40, LIMIT = 980, GAP = 18;
      let x = START_X, y = START_Y, rowH = 0;

      const title = document.createElement('div');
      title.style.position='absolute';
      title.style.left='16px';
      title.style.top='10px';
      title.style.fontWeight='900';
      title.style.fontSize='14px';
      title.innerHTML='2D ëª¨ë“œ: ë°© ì¡°ê°ì„ ë“œë˜ê·¸ë¡œ ë§ì¶”ê¸° <span style="font-size:12px;color:#666;font-weight:800;">(íœ =í™•ëŒ€/ì¶•ì†Œ, Shift+íœ =ìŠ¤í¬ë¡¤)</span>';
      twod.appendChild(title);

      globalData.forEach((d)=>{
        const color = EXCEL_COLORS[(d.id-1) % EXCEL_COLORS.length] || '#ddd';
        const wPx = d.w * SCALE_2D;
        const dPx = d.d * SCALE_2D;

        if (x + wPx > START_X + LIMIT){ x = START_X; y += rowH + GAP; rowH = 0; }

        const div = document.createElement('div');
        div.className='room2d';
        div.dataset.id = d.id;
        div.style.left = (d.x2d ?? (x+'px'));
        div.style.top = (d.y2d ?? (y+'px'));
        div.style.width = wPx+'px';
        div.style.height = dPx+'px';
        div.style.background = color;
        div.innerHTML = `<b>${d.name}</b><span style="font-size:11px;color:#111">(${d.w}Ã—${d.d}m)</span>`;
        twod.appendChild(div);

        x += wPx + GAP;
        rowH = Math.max(rowH, dPx);
      });
    }

    function save2DPositions(){
      const nodes = twod.querySelectorAll('.room2d');
      nodes.forEach(n=>{
        const id = parseInt(n.dataset.id,10);
        const m = globalData.find(x=>x.id===id);
        if (m){
          m.x2d = n.style.left;
          m.y2d = n.style.top;
        }
      });
    }

    twod.addEventListener('pointerdown', (e)=>{
      const target = e.target.closest('.room2d');
      if (!target) return;
      active2D = target;
      active2D.classList.add('dragging');
      const r = active2D.getBoundingClientRect();
      active2DOffset.x = e.clientX - r.left;
      active2DOffset.y = e.clientY - r.top;
    });
    twod.addEventListener('pointermove', (e)=>{
      if (!active2D) return;
      e.preventDefault();
      const c = twod.getBoundingClientRect();
      const cx = e.clientX - c.left + twod.scrollLeft;
      const cy = e.clientY - c.top + twod.scrollTop;
      active2D.style.left = (cx - active2DOffset.x) + 'px';
      active2D.style.top  = (cy - active2DOffset.y) + 'px';
    });
    function end2D(){
      if (!active2D) return;
      active2D.classList.remove('dragging');
      active2D = null;
      save2DPositions();
    }
    twod.addEventListener('pointerup', end2D);
    twod.addEventListener('pointerleave', end2D);

    // -----------------------------
    // 4) ì…ë©´(ì „ê°œë„)
    // -----------------------------
    function wallSVG(wallW, h, winArea, colorHex, label){
      const wallArea = wallW * h;
      const invalid = winArea > wallArea * 0.98;

      const aspect = 1.6;
      let patchW = winArea > 0 ? Math.sqrt(winArea * aspect) : 0;
      let patchH = winArea > 0 ? (winArea / patchW) : 0;

      patchW = clamp(patchW, 0, wallW * 0.9);
      patchH = clamp(patchH, 0, h * 0.8);

      const vbW = wallW;
      const vbH = h;

      const px = (vbW - patchW) / 2;
      const py = (vbH - patchH) * 0.45;

      const wallStroke = "#111827";
      const wallFill = colorHex;
      const winFill = invalid ? "rgba(255,77,77,0.45)" : "rgba(102,204,255,0.32)";
      const winStroke = invalid ? "#7f0000" : "#0b4aa2";

      const svg = `
        <svg viewBox="0 0 ${vbW} ${vbH}" width="100%" preserveAspectRatio="xMidYMid meet">
          <rect x="${vbW*0.08}" y="${vbH*0.08}" width="${vbW*(1-0.16)}" height="${vbH*(1-0.16)}"
            fill="${wallFill}" fill-opacity="0.75" stroke="${wallStroke}" stroke-width="${Math.max(0.02, vbW*0.01)}" rx="${vbW*0.05}" />
          ${
            winArea>0 ? `
            <rect x="${px}" y="${py}" width="${patchW}" height="${patchH}"
              fill="${winFill}" stroke="${winStroke}" stroke-width="${Math.max(0.02, vbW*0.01)}" rx="${vbW*0.04}" />
            ` : ''
          }
          <text x="${vbW*0.5}" y="${vbH*0.12}" text-anchor="middle" font-size="${Math.max(0.18, vbW*0.06)}"
            font-family="Malgun Gothic, system-ui" font-weight="900" fill="#111">${label}</text>
        </svg>
      `;
      return { svg, invalid };
    }

    function buildElevation(){
      elev.innerHTML = '';
      if (!globalData.length) return;

      const t = globalWallThicknessM;

      const totalFloorNet = globalData.reduce((s,r)=>s + (r.w*r.d), 0);
      const totalFloorGrossEst = globalData.reduce((s,r)=>s + ((r.w+2*t)*(r.d+2*t)), 0);
      const totalWallInner = globalData.reduce((s,r)=>s + ((r.w+r.d)*2*r.h), 0);
      const totalWallOuter = globalData.reduce((s,r)=>s + (((r.w+2*t)+(r.d+2*t))*2*r.h), 0);
      const totalWin = globalData.reduce((s,r)=>s + (r.winTotal||0), 0);
      const totalWallVolEst = globalData.reduce((s,r)=>{
        const periOuter = ((r.w+2*t)+(r.d+2*t))*2;
        return s + (periOuter * t * r.h);
      }, 0);

      const header = document.createElement('div');
      header.className = 'elevHeader';
      header.innerHTML = `
        <div style="font-weight:900;font-size:14px;">ì…ë©´(ì „ê°œë„) ìë™ ìƒì„±</div>
        <div style="margin-top:6px;font-size:12px;color:#666;line-height:1.45;">
          ë²½ë‘ê»˜: <b>${(t*1000).toFixed(0)}mm</b><br/>
          ë°© ${globalData.length}ê°œ Â· ìˆœë©´ì (ì—‘ì…€ ë™ì¼) <b>${totalFloorNet.toFixed(2)}ã¡</b> Â· ë²½ í¬í•¨ ì¶”ì •(ì°¸ê³ ) <b>${totalFloorGrossEst.toFixed(2)}ã¡</b><br/>
          ë²½ë©´ì (ë‚´ì¸¡) <b>${totalWallInner.toFixed(2)}ã¡</b> Â· ë²½ë©´ì (ì™¸ì¸¡ ì¶”ì •) <b>${totalWallOuter.toFixed(2)}ã¡</b> Â· ì°½ë©´ì (ì´) <b>${totalWin.toFixed(2)}ã¡</b><br/>
          ë²½ì²´ë¶€í”¼(ì¶”ì •) <b>${totalWallVolEst.toFixed(2)}ã¥</b><br/>
          <span style="color:#111;font-weight:900;">ì¤Œ:</span> <kbd>Ctrl</kbd>+íœ  (ë˜ëŠ” ìš°í•˜ë‹¨ +/âˆ’ ë²„íŠ¼) Â· <span style="color:#111;font-weight:900;">ìº¡ì²˜:</span> <kbd>P</kbd>
        </div>
      `;
      elev.appendChild(header);

      const grid = document.createElement('div');
      grid.className = 'elevGrid';
      elev.appendChild(grid);

      globalData.forEach((r)=>{
        const color = EXCEL_COLORS[(r.id-1) % EXCEL_COLORS.length] || "#ddd";

        const walls = [
          { key:'ì•', w:r.w, area:r.w*r.h, win:(r.win?.front||0) },
          { key:'ë’¤', w:r.w, area:r.w*r.h, win:(r.win?.back||0) },
          { key:'ì¢Œ', w:r.d, area:r.d*r.h, win:(r.win?.left||0) },
          { key:'ìš°', w:r.d, area:r.d*r.h, win:(r.win?.right||0) },
        ];

        const card = document.createElement('div');
        card.className = 'elevCard';

        const placedTxt = r.winTotal>0
          ? (r.winPlaced ? '<span class="ok">ìœ„ì¹˜ ì§€ì •ë¨</span>' : '<span class="bad">ìœ„ì¹˜ ë¯¸ì§€ì •</span>')
          : '<span style="color:#6b7280;font-weight:900;">ì—†ìŒ</span>';

        card.innerHTML = `
          <div class="elevTitle">${r.name}</div>
          <div class="elevMeta">
            ì¹˜ìˆ˜: <b>${r.w}Ã—${r.d}Ã—${r.h}m</b> Â· ë²½ë‘ê»˜ <b>${(t*1000).toFixed(0)}mm</b><br/>
            ì°½ë©´ì (ì´): <b>${(r.winTotal||0).toFixed(2)}ã¡</b> Â· ${placedTxt}
          </div>
        `;

        const row = document.createElement('div');
        row.className = 'wallRow';

        let anyInvalid = false;

        walls.forEach((winfo)=>{
          // âœ… ìœ„ì¹˜ ë¯¸ì§€ì •ì´ë©´ 'ê±°ì§“ ë°°ì¹˜' ì•ˆ í•¨: win=0ìœ¼ë¡œ ê·¸ë ¤ì„œ ì°½ íŒ¨ì¹˜ ì—†ìŒ
          const winToDraw = r.winPlaced ? winfo.win : 0;
          const { svg, invalid } = wallSVG(winfo.w, r.h, winToDraw, color, `${winfo.key}ë©´`);
          anyInvalid = anyInvalid || invalid;

          const box = document.createElement('div');
          box.className = 'wallBox';
          box.innerHTML = `
            <div class="wallLabel">${winfo.key}ë©´ Â· í­ ${winfo.w}m Â· ë†’ì´ ${r.h}m</div>
            <div class="wallSvgWrap">${svg}</div>
            <div style="margin-top:6px;font-size:12px;color:#666;">
              ë²½ë©´ì  ${winfo.area.toFixed(2)}ã¡ Â· ì°½ ${ (r.winPlaced ? winfo.win : 0).toFixed(2) }ã¡
            </div>
          `;
          row.appendChild(box);
        });

        card.appendChild(row);

        const note = document.createElement('div');
        if (r.winTotal > 0 && !r.winPlaced){
          note.className = 'note';
          note.textContent = 'â„¹ ì°½ ìœ„ì¹˜ê°€ ì—†ì–´ì„œ ì…ë©´ì—ëŠ” í‘œì‹œí•˜ì§€ ì•Šì•˜ì–´ìš”. (ì—´ ì¶”ê°€: ì°½ë©´ ë˜ëŠ” ì°½ì•/ì°½ë’¤/ì°½ì¢Œ/ì°½ìš°)';
        } else {
          note.className = anyInvalid ? 'warn' : 'good';
          note.textContent = anyInvalid
            ? 'âš  ì–´ë–¤ ë©´ì€ ì°½ë©´ì ì´ ë²½ë©´ì ë³´ë‹¤ ì»¤ìš”. ì…ë ¥(ì°½ë©´ì ) í™•ì¸!'
            : 'âœ“ ì°½ë©´ì /ë²½ë©´ì  ë¹„ìœ¨ì´ ì •ìƒ ë²”ìœ„ë¡œ ë³´ì…ë‹ˆë‹¤.';
        }
        card.appendChild(note);

        grid.appendChild(card);
      });
    }

    // -----------------------------
    // 5) 3D
    // -----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf2f2f2);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(12, 12, 16);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    threeEl.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.75));
    const dir = new THREE.DirectionalLight(0xffffff, 0.85);
    dir.position.set(50, 80, 50);
    dir.castShadow = true;
    scene.add(dir);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.GridHelper(100,100,0xbbbbbb,0xeeeeee));

    let pieces = [], ghosts = [], hitMeshes = [], labels3D = [];
    let labelsVisible = true, ghostsVisible = true;
    let shiftDown = false;

    const raycaster = new THREE.Raycaster();
    const dragPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
    const dragOffset = new THREE.Vector3();
    let dragging = false;
    let draggedGroup = null;

    function makeLabelSprite(text1, text2){
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = 'bold 40px Malgun Gothic';
      const w = ctx.measureText(text1).width + 70;
      canvas.width = Math.max(220, w);
      canvas.height = 120;
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 5;
      ctx.strokeRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#111';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 38px Malgun Gothic';
      ctx.fillText(text1, canvas.width/2, 42);
      ctx.font = '26px Malgun Gothic';
      ctx.fillText(text2, canvas.width/2, 86);

      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true }));
      sprite.scale.set(canvas.width/20, 6, 1);
      return sprite;
    }

    function addWindowPatchOnFace(group, face, w, d, h, winArea){
      if (!winArea || winArea <= 0) return false;

      const wallW = (face==='front' || face==='back') ? w : d;
      const wallArea = wallW * h;
      const invalid = winArea > wallArea * 0.98;

      const aspect = 1.6;
      let patchW = Math.sqrt(winArea * aspect);
      let patchH = winArea / patchW;

      patchW = Math.min(patchW, wallW * 0.9);
      patchH = Math.min(patchH, h * 0.8);

      const mat = new THREE.MeshBasicMaterial({
        color: invalid ? 0xff4d4d : 0x66ccff,
        transparent: true,
        opacity: invalid ? 0.45 : 0.32,
        side: THREE.DoubleSide
      });

      const geo = new THREE.PlaneGeometry(patchW, patchH);
      const mesh = new THREE.Mesh(geo, mat);
      const eps = 0.002;

      // center-ish placement
      const y = h*0.58;

      if (face === 'front'){
        mesh.position.set(0, y, -(d/2) + eps);
      } else if (face === 'back'){
        mesh.position.set(0, y, (d/2) - eps);
        mesh.rotation.y = Math.PI;
      } else if (face === 'left'){
        mesh.position.set(-(w/2) + eps, y, 0);
        mesh.rotation.y = Math.PI/2;
      } else if (face === 'right'){
        mesh.position.set((w/2) - eps, y, 0);
        mesh.rotation.y = -Math.PI/2;
      }

      group.add(mesh);

      const edge = new THREE.LineSegments(
        new THREE.EdgesGeometry(geo),
        new THREE.LineBasicMaterial({ color: invalid ? 0x7f0000 : 0x0b4aa2 })
      );
      edge.position.copy(mesh.position);
      edge.rotation.copy(mesh.rotation);
      group.add(edge);

      return invalid;
    }

    function create3DRoom(d, colorHex, wallT){
      const group = new THREE.Group();
      const w = d.w, depth = d.d, h = d.h;
      const t = wallT;

      const matColor = new THREE.Color(colorHex);

      // ë°”ë‹¥(ìˆœë©´ì  ê¸°ì¤€)
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(w, depth),
        new THREE.MeshStandardMaterial({ color: matColor, side: THREE.DoubleSide })
      );
      floor.rotation.x = -Math.PI/2;
      floor.position.y = 0.01;
      floor.receiveShadow = true;
      group.add(floor);

      // ë²½ (ì™¸ê³½ ë°”ê¹¥ìª½ìœ¼ë¡œ ë‘ê»˜)
      const wallMat = new THREE.MeshStandardMaterial({ color: matColor, roughness:0.75, transparent:true, opacity:0.88 });

      const front = new THREE.Mesh(new THREE.BoxGeometry(w + 2*t, h, t), wallMat);
      front.position.set(0, h/2, -(depth/2 + t/2));
      group.add(front);

      const back = front.clone();
      back.position.set(0, h/2, +(depth/2 + t/2));
      group.add(back);

      const side = new THREE.Mesh(new THREE.BoxGeometry(t, h, depth + 2*t), wallMat);
      side.position.set(-(w/2 + t/2), h/2, 0);
      group.add(side);

      const side2 = side.clone();
      side2.position.set(+(w/2 + t/2), h/2, 0);
      group.add(side2);

      // âœ… ì°½(ì§„ì‹¤ ëª¨ë“œ): ìœ„ì¹˜ ì§€ì •ëœ ë©´ë§Œ í‘œì‹œ
      let anyInvalid = false;
      if (d.winPlaced){
        anyInvalid = addWindowPatchOnFace(group, 'front', w, depth, h, d.win?.front || 0) || anyInvalid;
        anyInvalid = addWindowPatchOnFace(group, 'back',  w, depth, h, d.win?.back  || 0) || anyInvalid;
        anyInvalid = addWindowPatchOnFace(group, 'left',  w, depth, h, d.win?.left  || 0) || anyInvalid;
        anyInvalid = addWindowPatchOnFace(group, 'right', w, depth, h, d.win?.right || 0) || anyInvalid;
      }

      const label = makeLabelSprite(d.name, `(${d.w}Ã—${d.d}Ã—${d.h}m)`);
      label.position.set(0, h + 2.2, 0);
      label.visible = labelsVisible;
      group.add(label);
      labels3D.push(label);

      // ë“œë˜ê·¸ íˆíŠ¸
      const hit = new THREE.Mesh(
        new THREE.PlaneGeometry(w, depth),
        new THREE.MeshBasicMaterial({ visible:false })
      );
      hit.rotation.x = -Math.PI/2;
      hit.position.y = 0.12;
      hit.userData.parentGroup = group;
      group.add(hit);
      hitMeshes.push(hit);

      const winA = d.winTotal || 0;

      // ì§€í‘œ
      const floorNet = w * depth;
      const floorGrossEst = (w + 2*t) * (depth + 2*t);
      const periInner = (w + depth) * 2;
      const periOuter = ((w + 2*t) + (depth + 2*t)) * 2;
      const wallAreaInner = periInner * h;
      const wallAreaOuter = periOuter * h;
      const wallNetInner = Math.max(0, wallAreaInner - winA);
      const wallVolEst = periOuter * t * h;

      group.userData = {
        id: d.id,
        name: d.name,
        w, d: depth, h,
        wallT: t,
        winTotal: winA,
        winPlaced: !!d.winPlaced,
        win: d.win || {front:0,back:0,left:0,right:0},
        windowInvalid: anyInvalid,
        metrics: {
          floorNet, floorGrossEst,
          periInner, periOuter,
          wallAreaInner, wallAreaOuter,
          wallNetInner,
          wallVolEst
        },
        targetPos: new THREE.Vector3(),
      };

      return group;
    }

    function build3D(){
      pieces.forEach(p => scene.remove(p));
      ghosts.forEach(g => scene.remove(g));
      pieces = []; ghosts = []; hitMeshes = []; labels3D = [];
      tooltip.style.display = 'none';

      const t = globalWallThicknessM;

      let x=0, z=0, rowH=0;
      const LIMIT = 25;

      globalData.forEach(d=>{
        const color = EXCEL_COLORS[(d.id-1) % EXCEL_COLORS.length] || "#ccc";
        const g = create3DRoom(d, color, t);

        if (x + d.w > LIMIT){ x=0; z += rowH + 0.6; rowH=0; }

        g.userData.targetPos.set(x + d.w/2, 0, z + d.d/2);
        x += d.w + 0.6;
        rowH = Math.max(rowH, d.d);

        const ghost = new THREE.Mesh(
          new THREE.PlaneGeometry(d.w, d.d),
          new THREE.MeshBasicMaterial({ color:0x111111, transparent:true, opacity:0.14, side:THREE.DoubleSide })
        );
        ghost.rotation.x = -Math.PI/2;
        ghost.position.copy(g.userData.targetPos);
        ghost.position.y = 0.005;
        ghost.visible = ghostsVisible;
        scene.add(ghost);
        ghosts.push(ghost);

        g.position.set(g.userData.targetPos.x + (Math.random()-0.5)*15, 0, g.userData.targetPos.z + 8 + Math.random()*8);
        scene.add(g);
        pieces.push(g);
      });
    }

    // -----------------------------
    // 6) ëª¨ë“œ ìŠ¤ìœ„ì¹˜
    // -----------------------------
    function switchMode(next){
      if (mode === '2d') save2DPositions();
      mode = next;

      $('mode2d').classList.toggle('active', mode==='2d');
      $('mode3d').classList.toggle('active', mode==='3d');
      $('modeElev').classList.toggle('active', mode==='elev');

      twod.style.display = (mode==='2d') ? 'block' : 'none';
      threeEl.style.display = (mode==='3d') ? 'block' : 'none';
      elev.style.display = (mode==='elev') ? 'block' : 'none';
      tooltip.style.display = 'none';

      // âœ… ì…ë©´ ë“¤ì–´ê°€ë©´ ìë™ìœ¼ë¡œ ë©”ë‰´ ì ‘ê¸°(í™”ë©´ ë„“ê²Œ)
      if (mode === 'elev') setUiCollapsed(true);

      // âœ… ì¤Œ HUD on/off + ì¤Œ ì ìš©
      syncZoomHud();
      if (mode === '2d') setZoomForMode(twodZoom);
      if (mode === 'elev') setZoomForMode(elevZoom);

      if (globalData.length){
        if (mode==='2d') build2D();
        else if (mode==='3d') build3D();
        else buildElevation();
      }

      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    }

    $('mode2d').addEventListener('click', ()=>switchMode('2d'));
    $('mode3d').addEventListener('click', ()=>switchMode('3d'));
    $('modeElev').addEventListener('click', ()=>switchMode('elev'));

    // -----------------------------
    // 7) ë²„íŠ¼ë“¤
    // -----------------------------
    $('resetBtn').addEventListener('click', ()=>{
      if (confirm('ì´ˆê¸°í™”í• ê¹Œìš”? (ì…ë ¥/ë„í˜• ëª¨ë‘ ì‚­ì œ)')){
        hardReset({ clearInput:true });
        setDefaultStatus();
      }
    });

    $('clearInputBtn').addEventListener('click', ()=>{ inputEl.value=''; });

    $('sampleBtn').addEventListener('click', ()=>{
      inputEl.value =
`ê³µê°„ID\tê³µê°„ëª…\tê°€ë¡œ(m)\tì„¸ë¡œ(m)\të²½ë†’ì´(m)\tì°½ë©´ì (ã¡)\tì°½ë©´
1\tê±°ì‹¤\t5.3\t2.4\t2.3\t3.2\tì•
2\të°©1\t2.4\t2.4\t2.3\t0\t
3\të°©2\t3.8\t5.45\t2.3\t1.5\tìš°
4\të³µë„1\t1.55\t5.55\t2.3\t0\t
5\të°©3\t2.45\t5.55\t2.3\t2.0\të’¤`;
      setStatus(`<b>ìƒíƒœ</b><br/>ìƒ˜í”Œ ì…ë ¥ ì™„ë£Œ. ì´ì œ <b>[ë„ë©´ ìƒì„±]</b>ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.`);
    });

    $('pasteBtn').addEventListener('click', async ()=>{
      try{
        const t = await navigator.clipboard.readText();
        if (!t) { alert('í´ë¦½ë³´ë“œì— í…ìŠ¤íŠ¸ê°€ ì—†ì–´ìš”.'); return; }
        inputEl.value = t;
        setStatus(`<b>ìƒíƒœ</b><br/><span class="ok">í´ë¦½ë³´ë“œ ë‚´ìš© ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!</span> ì´ì œ <b>[ë„ë©´ ìƒì„±]</b> ëˆ„ë¥´ì„¸ìš”.`);
      }catch(e){
        alert('í´ë¦½ë³´ë“œ ì ‘ê·¼ì´ ì°¨ë‹¨ëì–´ìš”. ì§ì ‘ ë¶™ì—¬ë„£ê¸°(Ctrl+V)ë¡œ í•´ì£¼ì„¸ìš”.');
      }
    });

    $('buildBtn').addEventListener('click', ()=>{
      const t = getGlobalThickness();
      const { parsed, skipped } = parseText(inputEl.value || '');
      if (!parsed.length){
        setStatus(`<b>ìƒíƒœ</b><br/><span class="bad">ì¸ì‹ëœ ë°©ì´ 0ê°œ</span>ì…ë‹ˆë‹¤. ë°©ì´ë¦„/ê°€ë¡œ/ì„¸ë¡œ ë˜ëŠ” í‘œ í†µì§¸ë¡œ ë¶™ì—¬ë„£ê³  ë‹¤ì‹œ ëˆŒëŸ¬ì£¼ì„¸ìš”.`);
        return;
      }
      // ID ìë™ë³´ì •
      let nextId = 1;
      parsed.forEach(r=>{
        if (!r.id || r.id <= 0) r.id = nextId;
        nextId = Math.max(nextId, r.id + 1);
      });

      globalData = parsed;

      const totalFloorNet = globalData.reduce((s,r)=>s + (r.w*r.d), 0);
      const totalFloorGrossEst = globalData.reduce((s,r)=>s + ((r.w+2*t)*(r.d+2*t)), 0);
      const totalWallInner = globalData.reduce((s,r)=>s + ((r.w+r.d)*2*r.h), 0);
      const totalWallOuter = globalData.reduce((s,r)=>s + (((r.w+2*t)+(r.d+2*t))*2*r.h), 0);
      const totalWin = globalData.reduce((s,r)=>s + (r.winTotal||0), 0);
      const totalWallNetInner = Math.max(0, totalWallInner - totalWin);
      const totalWallVolEst = globalData.reduce((s,r)=>{
        const periOuter = ((r.w+2*t)+(r.d+2*t))*2;
        return s + (periOuter * t * r.h);
      }, 0);

      const placedCnt = globalData.filter(r=>r.winPlaced).length;
      const winCnt = globalData.filter(r=>(r.winTotal||0)>0).length;

      setStatus(
        `<b>ìƒíƒœ</b><br/>
         ë²½ë‘ê»˜: <b>${(t*1000).toFixed(0)}mm</b><br/>
         ë°© <b>${globalData.length}</b>ê°œ ì¸ì‹ / ê±´ë„ˆëœ€ <b>${skipped}</b>ì¤„<br/>
         ìˆœë©´ì (ì—‘ì…€ ë™ì¼): <b>${totalFloorNet.toFixed(2)}ã¡</b><br/>
         ë²½ í¬í•¨ ì¶”ì •(ì°¸ê³ ): <b>${totalFloorGrossEst.toFixed(2)}ã¡</b><br/>
         ë²½ë©´ì (ë‚´ì¸¡): <b>${totalWallInner.toFixed(2)}ã¡</b> / ì°½(ì´): <b>${totalWin.toFixed(2)}ã¡</b> / ì‹œê³µë©´ì (ë‚´ì¸¡-ì°½): <b>${totalWallNetInner.toFixed(2)}ã¡</b><br/>
         ë²½ë©´ì (ì™¸ì¸¡ ì¶”ì •): <b>${totalWallOuter.toFixed(2)}ã¡</b> / ë²½ì²´ë¶€í”¼(ì¶”ì •): <b>${totalWallVolEst.toFixed(2)}ã¥</b><br/>
         <span class="hint">ì°½ ì…ë ¥ ë°© ${winCnt}ê°œ ì¤‘ ìœ„ì¹˜ ì§€ì • ${placedCnt}ê°œ. (ìœ„ì¹˜ ì—†ìœ¼ë©´ ì…ë©´/3Dì— ê±°ì§“ ë°°ì¹˜ ì•ˆ í•¨)</span>`
      );

      if (mode==='2d') build2D();
      else if (mode==='3d') build3D();
      else buildElevation();
    });

    // JSON ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°(ë¡œì»¬ ë‹¤ìš´ë¡œë“œ/ì—…ë¡œë“œ)
    $('jsonSaveBtn').addEventListener('click', ()=>{
      const t = getGlobalThickness();
      if (!globalData.length){
        const { parsed } = parseText(inputEl.value || '');
        if (!parsed.length){ alert('ì €ì¥í•  ë°ì´í„°ê°€ ì—†ì–´ìš”. ë¨¼ì € ë¶™ì—¬ë„£ê³  ë„ë©´ ìƒì„±í•˜ì„¸ìš”.'); return; }
        globalData = parsed;
      }
      const payload = {
        app: "yugy.site",
        name: "ëš±ëšœë£¨ ë„ë©´ì†Œìƒìˆ  ë°©ëª©ë¡",
        version: "2.40",
        savedAt: new Date().toISOString(),
        wallThicknessMm: Math.round(t*1000),
        rooms: globalData
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type:"application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ddungdduru_rooms.json';
      a.click();
      URL.revokeObjectURL(url);
      alert('JSON ì €ì¥ ì™„ë£Œ! (ë‹¤ìš´ë¡œë“œ í´ë” í™•ì¸)');
    });

    $('jsonLoadBtn').addEventListener('click', ()=> $('jsonFile').click());
    $('jsonFile').addEventListener('change', async (e)=>{
      const f = e.target.files?.[0];
      if (!f) return;
      try{
        const text = await f.text();
        const obj = JSON.parse(text);
        const rooms = obj.rooms || obj.data || [];
        if (!Array.isArray(rooms) || !rooms.length) throw new Error('rooms ì—†ìŒ');

        const wt = obj.wallThicknessMm;
        if (isFinite(wt) && wt > 0){
          $('wallThk').value = String(wt);
        }

        const lines = [];
        // ìœ„ì¹˜ ê¸°ë°˜(ì°½ë©´) + ë©´ë³„(ì°½ì•/ë’¤/ì¢Œ/ìš°)ê¹Œì§€ ì§€ì›í•˜ëŠ” í—¤ë”ë¡œ ë³µì›
        lines.push("ê³µê°„ID\tê³µê°„ëª…\tê°€ë¡œ(m)\tì„¸ë¡œ(m)\të²½ë†’ì´(m)\tì°½ë©´ì (ã¡)\tì°½ë©´\tì°½ì•\tì°½ë’¤\tì°½ì¢Œ\tì°½ìš°");

        rooms.forEach((r,i)=>{
          const id = r.id ?? (i+1);
          const name = r.name ?? '';
          const w = r.w ?? 0;
          const d = r.d ?? r.depth ?? 0;
          const h = r.h ?? 2.3;

          const winTotal = (r.winTotal ?? r.winArea ?? 0);
          const win = r.win || {front:0,back:0,left:0,right:0};

          // ì°½ë©´ì€ "ì´ì´ í•œ ë©´ì—ë§Œ" ìˆì„ ë•Œë§Œ ì¶”ì •í•´ì„œ ë„£ê¸°
          let face = "";
          const faces = [
            {k:'front', v:win.front||0, tag:'ì•'},
            {k:'back',  v:win.back||0,  tag:'ë’¤'},
            {k:'left',  v:win.left||0,  tag:'ì¢Œ'},
            {k:'right', v:win.right||0, tag:'ìš°'},
          ].filter(x=>x.v>0);

          if (faces.length === 1 && Math.abs(faces[0].v - winTotal) < 1e-6){
            face = faces[0].tag;
          }

          lines.push(`${id}\t${name}\t${w}\t${d}\t${h}\t${winTotal}\t${face}\t${win.front||0}\t${win.back||0}\t${win.left||0}\t${win.right||0}`);
        });

        inputEl.value = lines.join('\n');

        globalData = parseText(inputEl.value).parsed;
        getGlobalThickness();

        if (mode==='2d') build2D();
        else if (mode==='3d') build3D();
        else buildElevation();

        setStatus(`<b>ìƒíƒœ</b><br/><span class="ok">JSON ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!</span> ë°© ${globalData.length}ê°œ.`);
      }catch(err){
        alert('JSON í˜•ì‹ì´ ë§ì§€ ì•Šì•„ìš”. (ì´ ì‚¬ì´íŠ¸ì—ì„œ ì €ì¥í•œ JSONì„ ì˜¬ë ¤ì£¼ì„¸ìš”)');
      }finally{
        e.target.value = '';
      }
    });

    // -----------------------------
    // 8) 3D ì¸í„°ë™ì…˜/íˆ´íŒ/ë“œë˜ê·¸
    // -----------------------------
    function getMouse(e){
      const rect = renderer.domElement.getBoundingClientRect();
      return {
        x: ((e.clientX - rect.left)/rect.width) * 2 - 1,
        y: -(((e.clientY - rect.top)/rect.height) * 2 - 1)
      };
    }

    threeEl.addEventListener('pointerdown', (e)=>{
      if (mode!=='3d' || !shiftDown) return;
      const m = getMouse(e);
      raycaster.setFromCamera(m, camera);
      const hits = raycaster.intersectObjects(hitMeshes);
      if (hits.length){
        dragging = true;
        draggedGroup = hits[0].object.userData.parentGroup;
        controls.enabled = false;
        tooltip.style.display = 'none';
        renderer.domElement.style.cursor = 'grabbing';
        raycaster.ray.intersectPlane(dragPlane, dragOffset);
        dragOffset.sub(draggedGroup.position);
      }
    });

    threeEl.addEventListener('pointermove', (e)=>{
      if (mode!=='3d') return;

      const m = getMouse(e);
      raycaster.setFromCamera(m, camera);

      if (dragging && draggedGroup){
        const p = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, p);
        draggedGroup.position.copy(p.sub(dragOffset));
        return;
      }

      const hits = raycaster.intersectObjects(hitMeshes);
      if (shiftDown && hits.length) renderer.domElement.style.cursor = 'grab';
      else renderer.domElement.style.cursor = 'auto';

      if (hits.length){
        const u = hits[0].object.userData.parentGroup.userData;
        const winTxt = (u.winTotal||0) > 0
          ? (u.winPlaced ? 'ì§€ì •ë¨' : 'ë¯¸ì§€ì •')
          : 'ì—†ìŒ';

        tooltip.innerHTML =
          `<b>${u.name}</b>
           <div class="ttRow"><span class="ttLbl">ì¹˜ìˆ˜</span><span class="ttVal">${u.w}Ã—${u.d}Ã—${u.h} m</span></div>
           <div class="ttRow"><span class="ttLbl">ë²½ë‘ê»˜</span><span class="ttVal">${(u.wallT*1000).toFixed(0)} mm</span></div>
           <div class="ttRow"><span class="ttLbl">ë°”ë‹¥(ìˆœ)</span><span class="ttVal">${u.metrics.floorNet.toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ë°”ë‹¥(ë²½í¬í•¨ ì¶”ì •)</span><span class="ttVal">${u.metrics.floorGrossEst.toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ë²½ë©´ì (ë‚´ì¸¡)</span><span class="ttVal">${u.metrics.wallAreaInner.toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ì°½ë©´ì (ì´)</span><span class="ttVal">${(u.winTotal||0).toFixed(2)} ã¡ (${winTxt})</span></div>
           <div class="ttRow"><span class="ttLbl">ì‹œê³µë©´ì (ë‚´ì¸¡-ì°½)</span><span class="ttVal">${u.metrics.wallNetInner.toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ë²½ì²´ë¶€í”¼(ì¶”ì •)</span><span class="ttVal">${u.metrics.wallVolEst.toFixed(2)} ã¥</span></div>
          `;
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 14) + 'px';
        tooltip.style.top  = (e.clientY + 14) + 'px';
      }else{
        tooltip.style.display = 'none';
      }
    });

    function endDrag(){
      if (dragging && draggedGroup){
        const t = draggedGroup.userData.targetPos;
        if (draggedGroup.position.distanceTo(t) < 0.5) draggedGroup.position.copy(t);
      }
      dragging = false;
      draggedGroup = null;
      controls.enabled = true;
      renderer.domElement.style.cursor = shiftDown ? 'grab' : 'auto';
    }
    threeEl.addEventListener('pointerup', endDrag);
    threeEl.addEventListener('pointerleave', endDrag);

    // -----------------------------
    // 9) ë‹¨ì¶•í‚¤: P ìº¡ì²˜ + ì¤Œ ë³´ì¡°
    // -----------------------------
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if (k==='shift') shiftDown = true;

      // zoom shortcuts (+/-) for 2D/elev
      if (mode==='2d' || mode==='elev'){
        if (k==='+' || k==='=' ) setZoomForMode((mode==='2d'?twodZoom:elevZoom) * 1.12);
        if (k==='-' || k==='_' ) setZoomForMode((mode==='2d'?twodZoom:elevZoom) * 0.90);
        if (k==='0') setZoomForMode(1);
      }

      if (k==='p'){
        if (mode==='2d'){
          html2canvas(twod).then((c)=>{
            const a = document.createElement('a');
            a.download = '2D_Plan.png';
            a.href = c.toDataURL('image/png');
            a.click();
          });
        } else if (mode==='elev'){
          html2canvas(elev).then((c)=>{
            const a = document.createElement('a');
            a.download = 'Elevation.png';
            a.href = c.toDataURL('image/png');
            a.click();
          });
        } else {
          renderer.render(scene, camera);
          const a = document.createElement('a');
          a.download = '3D_View.png';
          a.href = renderer.domElement.toDataURL('image/png');
          a.click();
        }
      }

      if (mode==='3d'){
        if (k==='g'){ ghostsVisible = !ghostsVisible; ghosts.forEach(x=>x.visible=ghostsVisible); }
        if (k==='l'){ labelsVisible = !labelsVisible; labels3D.forEach(x=>x.visible=labelsVisible); }
      }
    });
    window.addEventListener('keyup', (e)=>{
      if (e.key === 'Shift'){
        shiftDown = false;
        renderer.domElement.style.cursor = 'auto';
      }
    });

    // -----------------------------
    // 10) ë¦¬ì‚¬ì´ì¦ˆ/ì• ë‹ˆë©”ì´ì…˜
    // -----------------------------
    window.addEventListener('resize', ()=>{
      calcUiHide();
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (mode==='2d') build2D();
      if (mode==='elev') buildElevation();
    });

    function animate(){
      requestAnimationFrame(animate);
      if (mode==='3d'){
        controls.update();
        renderer.render(scene, camera);
      }
    }
    animate();

    // ì‹œì‘
    calcUiHide();
    applyUiCollapsed();
    getGlobalThickness();
    setDefaultStatus();

    // attach zoom handlers after elements exist
    attachWheelZoom(twod, '2d');
    attachWheelZoom(elev, 'elev');
    attachPinchZoom(twod, ()=>twodZoom, (z)=>{ if(mode!=='2d') return; setZoomForMode(z); });
    attachPinchZoom(elev, ()=>elevZoom, (z)=>{ if(mode!=='elev') return; setZoomForMode(z); });

    switchMode('3d');
    maybeAutoClearOnReload();
  </script>
</body>
</html>
