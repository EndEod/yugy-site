<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YUGY.ORG - ê±´ì¶• í†µí•© ì†”ë£¨ì…˜</title>
  <style>
    /* === ê¸°ë³¸ ìŠ¤íƒ€ì¼ === */
    body { margin: 0; overflow: hidden; font-family: 'Malgun Gothic', sans-serif; background: #f0f0f0; }
    
    /* === UI íŒ¨ë„ === */
    #ui-container {
      position: absolute; top: 10px; left: 10px;
      background: rgba(255, 255, 255, 0.96); /* ê°€ë…ì„±ì„ ìœ„í•´ ë¶ˆíˆ¬ëª…ë„ ì•½ê°„ ì˜¬ë¦¼ */
      padding: 16px; border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      width: 360px;
      z-index: 100;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid #ddd;
      display: flex; flex-direction: column; gap: 8px;
    }
    h3 { margin: 0 0 4px 0; color: #333; font-size: 18px; display: flex; align-items: center; justify-content: space-between; }
    .badge { background: #333; color: #fff; font-size: 10px; padding: 2px 6px; border-radius: 4px; vertical-align: middle; }
    
    /* === íƒ­ ë²„íŠ¼ === */
    .tab-container { display: flex; gap: 5px; margin-bottom: 4px; }
    .tab-btn {
      flex: 1; padding: 8px; border: none; border-radius: 6px;
      cursor: pointer; font-weight: bold; font-size: 13px;
      transition: all 0.2s;
    }
    .tab-btn.active { background: #333; color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .tab-btn.inactive { background: #e0e0e0; color: #777; }
    .tab-btn.inactive:hover { background: #d0d0d0; }

    textarea { 
      width: 100%; height: 100px; 
      font-size: 12px; border: 1px solid #ccc; border-radius: 4px; padding: 5px; box-sizing: border-box; resize: vertical;
    }
    
    /* === ë²„íŠ¼ ìŠ¤íƒ€ì¼ === */
    #buildBtn {
      width: 100%; padding: 12px; background: #007bff; color: white;
      border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px;
      margin-top: 5px;
    }
    #buildBtn:hover { background: #0056b3; }

    /* âœ… ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´ ë²„íŠ¼ (ë„¤ì´ë²„ ê·¸ë¦°) */
    #storeBtn {
      display: block; width: 100%; padding: 12px; 
      background: #03C75A; color: white;
      border: none; border-radius: 6px; cursor: pointer; 
      font-weight: bold; font-size: 14px; text-align: center; text-decoration: none;
      box-sizing: border-box; margin-top: 5px;
      box-shadow: 0 2px 5px rgba(3, 199, 90, 0.3);
      transition: background 0.2s;
    }
    #storeBtn:hover { background: #02b351; }

    #info { font-size: 12px; color: #555; line-height: 1.4; background: #f9f9f9; padding: 10px; border-radius: 6px; margin-top: 5px;}
    .hint { font-size: 11px; color: #888; margin-bottom: 2px; }
    kbd { background:#fff; border:1px solid #ccc; padding:1px 5px; border-radius:4px; font-family: monospace; }

    /* === ë·°ì–´ ì˜ì—­ === */
    #viewer-area {
      position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
      z-index: 1;
    }
    
    /* 2D ìº”ë²„ìŠ¤ (ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•˜ê²Œ) */
    #canvas-container {
      width: 100%; height: 100%; overflow: auto; display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
      background: #fff;
    }
    canvas { display: block; margin: 20px auto; box-shadow: 0 0 20px rgba(0,0,0,0.1); }

    /* 3D ì»¨í…Œì´ë„ˆ */
    #three-container { width: 100%; height: 100%; display: block; }

    /* íˆ´íŒ */
    #tooltip {
      position: fixed; z-index: 9999; display: none; pointer-events: none;
      background: rgba(20,20,20,0.9); color: #fff; padding: 10px 14px;
      border-radius: 8px; font-size: 13px; line-height: 1.5;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3); backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.2);
    }
    #tooltip b { font-size: 14px; color: #ffd700; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>

  <div id="ui-container">
    <h3>ì—¬ê¸°ê±´ì¶•ì‚¬ì‚¬ë¬´ì†Œ <span class="badge">v2.1</span></h3>
    
    <div class="tab-container">
      <button id="tab2D" class="tab-btn inactive">ğŸ“Š ì—‘ì…€ í‚¤íŠ¸(2D)</button>
      <button id="tab3D" class="tab-btn active">ğŸ§Š 3D íˆ¬ì‹œë„</button>
    </div>

    <div class="hint">ì—‘ì…€ ë°ì´í„°ë¥¼ ë³µì‚¬í•´ì„œ ì•„ë˜ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.</div>
    <textarea id="dataInput" placeholder="ì˜ˆì‹œ ë°ì´í„°)
1	ê±°ì‹¤	5.0	4.0	20.0	20.0	18.0	2.4	43.2
2	ì¹¨ì‹¤	3.5	3.0	10.5	10.5	13.0	2.4	31.2"></textarea>

    <button id="buildBtn">ğŸ—ï¸ ë„ë©´ ìƒì„±í•˜ê¸° (Build)</button>

    <div id="info">
      <div id="info-2d" style="display:none;">
        <b>[2D ëª¨ë“œ ì•ˆë‚´]</b><br/>
        âœ… ìœ„ìª½: í‰ë©´ë„ (Stack)<br/>
        âœ… ì•„ë˜ìª½: ë²½ì²´ ì „ê°œë„ (Unfolding)<br/>
        âœ… ë§ˆìš°ìŠ¤ íœ ë¡œ ìŠ¤í¬ë¡¤í•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.
      </div>
      <div id="info-3d">
        <b>[3D ëª¨ë“œ ì•ˆë‚´]</b><br/>
        âœ… <kbd>Shift</kbd> + ë“œë˜ê·¸: ë°© ì´ë™<br/>
        âœ… ì™¼ìª½í´ë¦­: íšŒì „ / ì˜¤ë¥¸ìª½: ì´ë™ / íœ : ì¤Œ<br/>
        âœ… <kbd>G</kbd>: ì •ë‹µ ìœ ë ¹ ìˆ¨ê¸°ê¸°/ë³´ê¸°<br/>
        âœ… ìœ ë ¹ ê·¼ì²˜ì— ë†“ìœ¼ë©´ 'ì°©' ë¶™ìŠµë‹ˆë‹¤.
      </div>
    </div>

    <a href="https://smartstore.naver.com/kiendeod_susutto" target="_blank" id="storeBtn">
      ğŸ›ï¸ ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´ êµ¬ê²½ê°€ê¸°
    </a>
  </div>

  <div id="tooltip"></div>

  <div id="viewer-area">
    <div id="canvas-container">
      <canvas id="excelCanvas"></canvas>
    </div>
    <div id="three-container"></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ==========================================
    // 1. ê³µí†µ ë°ì´í„° ë° ìœ í‹¸ë¦¬í‹°
    // ==========================================
    
    // ëš±ëšœë£¨ ì—‘ì…€ ë§¤í¬ë¡œ ìƒ‰ìƒí‘œ (RGB -> Hex ë³€í™˜)
    const EXCEL_COLORS = [
      "#FFCCCC", "#FFE5CC", "#FFFFCC", "#E5FFCC", "#CCFFCC", "#CCFFE5", "#CCFFFF", "#CCE5FF", "#CCCCFF", "#E5CCFF",
      "#FFCCFF", "#FFCCE5", "#FFB2B2", "#FFD6A5", "#FFEF9F", "#CAE799", "#A6E3A1", "#99DDCC", "#9FDBFF", "#ADC1FF",
      "#C8B2FF", "#E0B2FF", "#FFB2F5", "#FFB2D7", "#FFB2B2", "#FF8282", "#FFAA64", "#FFD246", "#B4DC5A", "#78D296"
    ];

    let globalData = []; // íŒŒì‹±ëœ ë°ì´í„° ì €ì¥ì†Œ
    let currentMode = '3d'; // '2d' or '3d'

    function splitCols(line) {
      const t = (line || '').trim();
      if (!t) return null;
      if (t.includes('ê³µê°„ID') || t.includes('ê³µê°„ëª…')) return null; // í—¤ë” ìŠ¤í‚µ
      if (t.includes('\t')) return t.split('\t').map(s => s.trim());
      if (t.includes(',')) return t.split(',').map(s => s.trim());
      return t.split(/\s+/).map(s => s.trim());
    }

    function parseData() {
      const input = document.getElementById('dataInput').value || '';
      const lines = input.split(/\r?\n/);
      const parsed = [];

      lines.forEach(line => {
        const cols = splitCols(line);
        if (!cols) return;
        
        // ë°ì´í„° í¬ë§·: [0]ID [1]ì´ë¦„ [2]ê°€ë¡œ [3]ì„¸ë¡œ ... [7]ë†’ì´(ì˜µì…˜)
        if (cols.length >= 4 && !isNaN(Number(cols[0])) && cols[1]) {
          const id = parseInt(cols[0], 10);
          const name = cols[1];
          const w = parseFloat(cols[2]);
          const d = parseFloat(cols[3]);
          const h = parseFloat(cols[7]) || 2.4; // ì—‘ì…€ ë¡œì§: ì—†ìœ¼ë©´ 2.4

          if ([w, d].every(Number.isFinite)) {
            parsed.push({ id, name, w, d, h });
          }
        }
      });
      globalData = parsed;
      return parsed;
    }

    // ==========================================
    // 2. 2D ì—‘ì…€ ëª¨ë“œ (Canvas API)
    // ==========================================
    const canvasContainer = document.getElementById('canvas-container');
    const canvas = document.getElementById('excelCanvas');
    const ctx = canvas.getContext('2d');
    const SCALE_2D = 40; // 1m = 40px

    function drawExcelMode() {
      if (!globalData.length) return;

      // ìº”ë²„ìŠ¤ í¬ê¸° ê³„ì‚° (ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•˜ê²Œ ë„‰ë„‰íˆ)
      // ìƒë‹¨: í‰ë©´ë„ ì˜ì—­, í•˜ë‹¨: ì „ê°œë„ ì˜ì—­
      let currentY = 50;
      let maxWidth = 800;
      
      // 1. í‰ë©´ë„ ê·¸ë¦¬ê¸° ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ë†’ì´ ê³„ì‚°
      globalData.forEach(d => {
        currentY += (d.d * SCALE_2D) + 20; // ì„¸ë¡œ ìŒ“ê¸°
        maxWidth = Math.max(maxWidth, (d.w * SCALE_2D) + 200);
      });

      const floorPlanEnd = currentY + 50;
      currentY += 80; // êµ¬ë¶„ì„  ê°„ê²©

      // 2. ë²½ì²´ ì „ê°œë„ ê·¸ë¦¬ê¸° ì‹œë®¬ë ˆì´ì…˜
      // ë²½ì€ í•œ ì¤„ì— (ê°€ë¡œ + ì„¸ë¡œ + ê°€ë¡œ + ì„¸ë¡œ) * SCALE
      globalData.forEach(d => {
        const totalWallLen = (d.w * 2 + d.d * 2);
        maxWidth = Math.max(maxWidth, (totalWallLen * SCALE_2D) + 100);
        currentY += (d.h * SCALE_2D) + 60; // í…ìŠ¤íŠ¸ ê³µê°„ í¬í•¨
      });

      // ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ
      canvas.width = maxWidth;
      canvas.height = currentY + 100;
      
      // ë°°ê²½ ì´ˆê¸°í™”
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸° (ì—‘ì…€ ëŠë‚Œ)
      ctx.strokeStyle = "#eee";
      ctx.lineWidth = 1;
      for(let x=0; x<canvas.width; x+=SCALE_2D) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for(let y=0; y<canvas.height; y+=SCALE_2D) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

      // === ì„¹ì…˜ 1: ë°”ë‹¥ í‰ë©´ë„ (Floor Plan) ===
      let cursorY = 50;
      const startX = 50;

      ctx.fillStyle = "#333";
      ctx.font = "bold 20px Malgun Gothic";
      ctx.fillText("1. ë°”ë‹¥ í‰ë©´ë„ (Floor Plan)", 20, 30);

      globalData.forEach((d, idx) => {
        const color = EXCEL_COLORS[(d.id - 1) % EXCEL_COLORS.length] || "#ddd";
        const wPx = d.w * SCALE_2D;
        const dPx = d.d * SCALE_2D;

        // ë„í˜• ê·¸ë¦¬ê¸°
        ctx.fillStyle = color;
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 2;
        ctx.fillRect(startX, cursorY, wPx, dPx);
        ctx.strokeRect(startX, cursorY, wPx, dPx);

        // í…ìŠ¤íŠ¸ (ì¤‘ì•™ ì •ë ¬)
        ctx.fillStyle = "#000";
        ctx.font = "14px Malgun Gothic";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(d.name, startX + wPx/2, cursorY + dPx/2 - 10);
        ctx.font = "12px Malgun Gothic";
        ctx.fillText(`(${d.w} x ${d.d})`, startX + wPx/2, cursorY + dPx/2 + 8);

        cursorY += dPx + 20; // ë‹¤ìŒ ì¹¸ìœ¼ë¡œ ì´ë™
      });

      // === êµ¬ë¶„ì„  ===
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(20, floorPlanEnd + 20);
      ctx.lineTo(canvas.width - 20, floorPlanEnd + 20);
      ctx.stroke();

      // === ì„¹ì…˜ 2: ë²½ì²´ ì „ê°œë„ (Wall Unfolding) ===
      cursorY = floorPlanEnd + 60;
      ctx.fillStyle = "#333";
      ctx.textAlign = "left";
      ctx.font = "bold 20px Malgun Gothic";
      ctx.fillText("2. ë²½ì²´ ì „ê°œë„ (Wall Unfolding)", 20, cursorY - 20);

      globalData.forEach((d, idx) => {
        const color = EXCEL_COLORS[(d.id - 1) % EXCEL_COLORS.length] || "#ddd";
        const hPx = d.h * SCALE_2D;
        let currentX = 50;

        // ë²½ A, B, C, D ìˆœì„œ (ì•, ìš°, ë’¤, ì¢Œ)
        const walls = [
          { name: "ë²½-A(ì•)", len: d.w },
          { name: "ë²½-B(ìš°)", len: d.d },
          { name: "ë²½-C(ë’¤)", len: d.w },
          { name: "ë²½-D(ì¢Œ)", len: d.d }
        ];

        // ë£¸ ì´ë¦„ í‘œì‹œ
        ctx.fillStyle = "#000";
        ctx.font = "bold 14px Malgun Gothic";
        ctx.textAlign = "left";
        ctx.fillText(`[${d.name}] ë†’ì´: ${d.h}m`, 20, cursorY + hPx/2);

        // 4ê°œ ë²½ ê·¸ë¦¬ê¸°
        currentX = 150; // ì´ë¦„ ì˜†ë¶€í„° ì‹œì‘
        walls.forEach(w => {
          const wLenPx = w.len * SCALE_2D;
          
          ctx.fillStyle = color;
          ctx.strokeStyle = "#555";
          ctx.lineWidth = 1;
          ctx.fillRect(currentX, cursorY, wLenPx, hPx);
          ctx.strokeRect(currentX, cursorY, wLenPx, hPx);

          // ë²½ í…ìŠ¤íŠ¸
          ctx.fillStyle = "#333";
          ctx.font = "11px Malgun Gothic";
          ctx.textAlign = "center";
          ctx.fillText(w.name, currentX + wLenPx/2, cursorY + hPx/2 - 8);
          ctx.fillText(`(${w.len}x${d.h})`, currentX + wLenPx/2, cursorY + hPx/2 + 8);

          currentX += wLenPx + 5; // ê°„ê²©
        });

        cursorY += hPx + 40; // ë‹¤ìŒ ì¤„
      });
    }

    // ==========================================
    // 3. 3D íˆ¬ì‹œë„ ëª¨ë“œ (Three.js)
    // ==========================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0); // ì—‘ì…€ ëŠë‚Œì˜ ë°ì€ ë°°ê²½

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 12, 16);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('three-container').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 80, 50);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Grid Helper
    const gridHelper = new THREE.GridHelper(100, 100, 0xbbbbbb, 0xeeeeee);
    scene.add(gridHelper);

    let pieces = [];
    let ghosts = [];
    let hitMeshes = [];
    
    // ë“œë˜ê·¸ ê´€ë ¨
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    let dragging = false, draggedGroup = null;
    let dragOffset = new THREE.Vector3();
    let shiftDown = false;
    let ghostsVisible = true;

    // 3D ë£¸ ìƒì„±
    function create3DRoom(d, colorHex) {
      const group = new THREE.Group();
      const w = d.w; const depth = d.d; const h = d.h;
      
      const matColor = new THREE.Color(colorHex);
      const floorGeo = new THREE.PlaneGeometry(w, depth);
      const floorMat = new THREE.MeshStandardMaterial({ color: matColor, side: THREE.DoubleSide });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI/2; 
      floor.position.y = 0.01;
      floor.receiveShadow = true;
      group.add(floor);

      // ë²½ ìƒì„± (4ë©´)
      const wallMat = new THREE.MeshStandardMaterial({ color: matColor, roughness: 0.7 });
      const wallThick = 0.1;

      // ì•ë’¤ ë²½
      const w1 = new THREE.Mesh(new THREE.BoxGeometry(w, h, wallThick), wallMat);
      w1.position.set(0, h/2, -depth/2); group.add(w1);
      const w2 = w1.clone(); w2.position.set(0, h/2, depth/2); group.add(w2);

      // ì¢Œìš° ë²½
      const w3 = new THREE.Mesh(new THREE.BoxGeometry(depth, h, wallThick), wallMat);
      w3.rotation.y = Math.PI/2; w3.position.set(-w/2, h/2, 0); group.add(w3);
      const w4 = w3.clone(); w4.rotation.y = Math.PI/2; w4.position.set(w/2, h/2, 0); group.add(w4);

      // ë¼ë²¨ (ìŠ¤í”„ë¼ì´íŠ¸)
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = 'bold 40px Malgun Gothic';
      const text = `${d.name}\n(${d.w}x${d.d})`;
      const textWidth = ctx.measureText(d.name).width + 40;
      canvas.width = textWidth; canvas.height = 100;
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#000';
      ctx.font = 'bold 30px Malgun Gothic';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(d.name, canvas.width/2, 30);
      ctx.font = '24px Malgun Gothic';
      ctx.fillText(`(${d.w}x${d.d})`, canvas.width/2, 70);
      
      const tex = new THREE.CanvasTexture(canvas);
      const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
      label.scale.set(textWidth/20, 5, 1);
      label.position.set(0, h + 1.5, 0);
      group.add(label);

      // ë“œë˜ê·¸ìš© íˆíŠ¸ë°•ìŠ¤
      const hitMesh = new THREE.Mesh(new THREE.PlaneGeometry(w, depth), new THREE.MeshBasicMaterial({visible:false}));
      hitMesh.rotation.x = -Math.PI/2;
      hitMesh.position.y = 0.1;
      hitMesh.userData.parentGroup = group;
      group.add(hitMesh);
      hitMeshes.push(hitMesh);

      group.userData = { id: d.id, w: d.w, d: d.d, h: d.h, targetPos: new THREE.Vector3() };
      return group;
    }

    function build3DScene() {
      // ì´ˆê¸°í™”
      pieces.forEach(p => scene.remove(p));
      ghosts.forEach(g => scene.remove(g));
      pieces = []; ghosts = []; hitMeshes = [];

      let x = 0, z = 0, rowH = 0;
      const LIMIT = 20;

      globalData.forEach((d, idx) => {
        const color = EXCEL_COLORS[(d.id - 1) % EXCEL_COLORS.length] || "#cccccc";
        const group = create3DRoom(d, color);
        
        // ì •ë‹µ ìœ„ì¹˜ ê³„ì‚° (Grid Packing)
        if (x + d.w > LIMIT) { x = 0; z += rowH + 0.5; rowH = 0; }
        group.userData.targetPos.set(x + d.w/2, 0, z + d.d/2);
        x += d.w + 0.5;
        rowH = Math.max(rowH, d.d);

        // ìœ ë ¹(ì •ë‹µì§€) ìƒì„±
        const ghostGeo = new THREE.PlaneGeometry(d.w, d.d);
        const ghostMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.15, transparent: true, side: THREE.DoubleSide });
        const ghost = new THREE.Mesh(ghostGeo, ghostMat);
        ghost.rotation.x = -Math.PI/2;
        ghost.position.copy(group.userData.targetPos);
        ghost.position.y = 0.005;
        scene.add(ghost);
        ghosts.push(ghost);

        // ì¡°ê° í©ë¿Œë¦¬ê¸°
        group.position.set(group.userData.targetPos.x + (Math.random()-0.5)*10, 0, group.userData.targetPos.z + 5 + Math.random()*5);
        
        scene.add(group);
        pieces.push(group);
      });
    }

    // ==========================================
    // 4. ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë° í†µí•© ë¡œì§
    // ==========================================
    
    // ëª¨ë“œ ì „í™˜ íƒ­
    const tab2D = document.getElementById('tab2D');
    const tab3D = document.getElementById('tab3D');
    const info2D = document.getElementById('info-2d');
    const info3D = document.getElementById('info-3d');

    function switchMode(mode) {
      currentMode = mode;
      if (mode === '2d') {
        tab2D.className = 'tab-btn active'; tab3D.className = 'tab-btn inactive';
        document.getElementById('canvas-container').style.display = 'block';
        document.getElementById('three-container').style.display = 'none';
        info2D.style.display = 'block'; info3D.style.display = 'none';
        drawExcelMode(); // 2D ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      } else {
        tab3D.className = 'tab-btn active'; tab2D.className = 'tab-btn inactive';
        document.getElementById('canvas-container').style.display = 'none';
        document.getElementById('three-container').style.display = 'block';
        info2D.style.display = 'none'; info3D.style.display = 'block';
        if (globalData.length > 0 && pieces.length === 0) build3DScene(); // ë°ì´í„°ëŠ” ìˆëŠ”ë° 3Dê°€ ë¹„ì—ˆìœ¼ë©´ ìƒì„±
      }
    }

    tab2D.addEventListener('click', () => switchMode('2d'));
    tab3D.addEventListener('click', () => switchMode('3d'));

    // ë¹Œë“œ ë²„íŠ¼
    document.getElementById('buildBtn').addEventListener('click', () => {
      parseData();
      if (globalData.length === 0) { alert("ë°ì´í„°ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”!"); return; }
      
      drawExcelMode(); // 2D ì—…ë°ì´íŠ¸
      build3DScene();  // 3D ì—…ë°ì´íŠ¸
    });

    // 3D ì¸í„°ë™ì…˜ (Shift í‚¤, ë“œë˜ê·¸)
    window.addEventListener('keydown', e => { if(e.key==='Shift') shiftDown=true; if(e.key.toLowerCase()==='g') { ghostsVisible=!ghostsVisible; ghosts.forEach(g=>g.visible=ghostsVisible); } });
    window.addEventListener('keyup', e => { if(e.key==='Shift') shiftDown=false; });

    const threeContainer = document.getElementById('three-container');
    threeContainer.addEventListener('pointerdown', onPointerDown);
    threeContainer.addEventListener('pointermove', onPointerMove);
    threeContainer.addEventListener('pointerup', onPointerUp);

    function onPointerDown(e) {
      if(!shiftDown || currentMode !== '3d') return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
      mouse.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(hitMeshes);
      if(intersects.length > 0) {
        dragging = true;
        draggedGroup = intersects[0].object.userData.parentGroup;
        controls.enabled = false;
        raycaster.ray.intersectPlane(dragPlane, dragOffset);
        dragOffset.sub(draggedGroup.position);
      }
    }
    function onPointerMove(e) {
      if(!dragging || !draggedGroup) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
      mouse.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(dragPlane, intersectPoint);
      draggedGroup.position.copy(intersectPoint.sub(dragOffset));
    }
    function onPointerUp() {
      if(dragging && draggedGroup) {
        // ìŠ¤ëƒ… ë¡œì§
        const t = draggedGroup.userData.targetPos;
        if(draggedGroup.position.distanceTo(t) < 0.5) {
          draggedGroup.position.copy(t);
        }
      }
      dragging = false; draggedGroup = null; controls.enabled = true;
    }

    // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if(currentMode === '2d') drawExcelMode();
    });

    function animate() {
      requestAnimationFrame(animate);
      if(currentMode === '3d') {
        controls.update();
        renderer.render(scene, camera);
      }
    }
    animate();

    // ì´ˆê¸°í™” ì‹œ 3D ëª¨ë“œ ê¸°ë³¸ ì„¤ì •
    switchMode('3d');

  </script>
</body>
</html>